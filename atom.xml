<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://kryptonzy.github.io/blog/atom.xml" rel="self"/>
  
  <link href="https://kryptonzy.github.io/blog/"/>
  <updated>2024-10-14T14:17:11.810Z</updated>
  <id>https://kryptonzy.github.io/blog/</id>
  
  <author>
    <name>Kryptonzy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>个人网站</title>
    <link href="https://kryptonzy.github.io/blog/2024/10/14/my%20first%20project/"/>
    <id>https://kryptonzy.github.io/blog/2024/10/14/my%20first%20project/</id>
    <published>2024-10-14T11:40:31.201Z</published>
    <updated>2024-10-14T14:17:11.810Z</updated>
    
    <content type="html"><![CDATA[<h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>自己写前后端代码（AI辅助）建立个人网站</p><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>学习相关的前后端以及devops知识</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;任务&quot;&gt;&lt;a href=&quot;#任务&quot; class=&quot;headerlink&quot; title=&quot;任务&quot;&gt;&lt;/a&gt;任务&lt;/h2&gt;&lt;p&gt;自己写前后端代码（AI辅助）建立个人网站&lt;/p&gt;
&lt;h2 id=&quot;目的&quot;&gt;&lt;a href=&quot;#目的&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>不同语言的NLP</title>
    <link href="https://kryptonzy.github.io/blog/2024/09/28/NLP/"/>
    <id>https://kryptonzy.github.io/blog/2024/09/28/NLP/</id>
    <published>2024-09-28T07:02:57.410Z</published>
    <updated>2024-09-28T07:04:09.519Z</updated>
    
    <content type="html"><![CDATA[<p>在自然语言处理（NLP）中，处理不同语言时，某些阶段会有所不同，而其他阶段则基本相同。以下是对这些相同和不同阶段的详细说明：</p><hr><p><strong>相同或类似的阶段：</strong></p><ol><li><p><strong>任务定义和问题建模：</strong></p><ul><li><strong>统一的NLP任务</strong>：无论语言如何，核心的NLP任务（如文本分类、情感分析、命名实体识别、机器翻译等）在定义和目标上是相似的。</li><li><strong>模型训练流程</strong>：数据预处理、模型训练、验证和测试的基本流程一致。</li></ul></li><li><p><strong>算法和模型架构：</strong></p><ul><li><strong>机器学习算法</strong>：如朴素贝叶斯、支持向量机、决策树等传统算法在不同语言的文本数据上都可应用。</li><li><strong>深度学习架构</strong>：神经网络模型（如CNN、RNN、Transformer）的基本架构和训练方法在各语言间通用。</li></ul></li><li><p><strong>评估方法和指标：</strong></p><ul><li><strong>评估指标</strong>：准确率、精确率、召回率、F1值、BLEU分数等评估指标适用于所有语言。</li><li><strong>交叉验证和测试方法</strong>：用于评估模型性能的技术在不同语言中一致。</li></ul></li><li><p><strong>高层次的语义理解：</strong></p><ul><li><strong>主题模型</strong>：如LDA主题模型，可用于不同语言的主题提取。</li><li><strong>语义相似度计算</strong>：基于词向量或句向量的相似度计算方法在不同语言中类似。</li></ul></li></ol><hr><p><strong>不同或需要适应的阶段：</strong></p><ol><li><p><strong>文本预处理：</strong></p><ul><li><strong>分词和标记化（Tokenization）</strong>：<ul><li><strong>中文、日文、韩文</strong>：没有明显的词与词之间的空格，需要使用分词算法。</li><li><strong>英语、法语、德语</strong>：以空格和标点符号作为天然的分隔符，但仍需考虑缩写、连字符等特殊情况。</li></ul></li><li><strong>词形归并和词干提取</strong>：<ul><li><strong>形态丰富的语言</strong>（如阿拉伯语、俄语）：词形变化多样，需要复杂的词形归并算法。</li><li><strong>形态简单的语言</strong>（如英语）：词干提取相对简单。</li></ul></li></ul></li><li><p><strong>语法和句法分析：</strong></p><ul><li><strong>语序差异</strong>：不同语言的主谓宾结构可能不同，如日语通常采用主宾谓结构，需要调整解析器。</li><li><strong>句法规则</strong>：每种语言都有特定的语法规则，解析器需要针对特定语言进行训练或规则制定。</li><li><strong>依存关系和短语结构</strong>：依存句法和成分句法在不同语言中的表现形式不同。</li></ul></li><li><p><strong>词汇和语义处理：</strong></p><ul><li><strong>多义词和同形异义词</strong>：不同语言的多义现象需要特定的消歧算法。</li><li><strong>习语和固定表达</strong>：文化特定的表达方式需要特殊处理。</li></ul></li><li><p><strong>语言资源和数据：</strong></p><ul><li><strong>训练数据的可用性</strong>：主流语言的数据资源丰富，而小语种可能缺乏足够的数据。</li><li><strong>词典和知识库</strong>：需要为每种语言构建或获取相应的词典、同义词库、反义词库等。</li></ul></li><li><p><strong>字符集和编码：</strong></p><ul><li><strong>不同的字符集</strong>：如拉丁字母、汉字、西里尔字母等，需要确保系统支持相应的编码（如UTF-8）。</li><li><strong>特殊字符处理</strong>：如重音符号、变音符号，需要在预处理时保留或正确转换。</li></ul></li><li><p><strong>语音和发音特性（如果涉及语音处理）：</strong></p><ul><li><strong>音素和音节结构</strong>：不同语言的音素集合和音节结构不同，影响语音识别和合成。</li><li><strong>语调和重音</strong>：在某些语言中，语调改变可能导致词义变化，需要特别关注。</li></ul></li><li><p><strong>文化和社会背景：</strong></p><ul><li><strong>命名实体</strong>：人名、地名、组织名等在不同文化中有不同的构成方式，需要特定的识别方法。</li><li><strong>时间和日期格式</strong>：日期、时间、数字的表示方式因语言和文化而异，需要在信息抽取时进行转换。</li></ul></li></ol><hr><p><strong>总结：</strong></p><ul><li><p><strong>不同的阶段主要集中在</strong>：</p><ul><li><strong>文本预处理</strong>：分词、词形归并、字符编码等，需要针对语言特性进行调整。</li><li><strong>语法和语义分析</strong>：语法规则、句法结构、文化特定的表达方式，需要特定的模型和规则。</li><li><strong>资源和数据</strong>：数据的可获得性、质量以及工具的支持程度因语言而异。</li></ul></li><li><p><strong>相同或类似的阶段包括</strong>：</p><ul><li><strong>任务定义和目标</strong>：NLP的核心任务在各语言间基本一致。</li><li><strong>算法和模型</strong>：机器学习和深度学习的基本原理和模型架构可跨语言应用。</li><li><strong>评估方法</strong>：模型性能的评估标准在不同语言的任务中通用。</li></ul></li></ul><hr><p><strong>应对语言差异的策略：</strong></p><ol><li><strong>多语言模型</strong>：使用跨语言的预训练模型，如XLM-R、mBERT，可以在多个语言间共享表示，减少对单一语言数据的依赖。</li><li><strong>数据增强和迁移学习</strong>：从高资源语言迁移知识到低资源语言，通过翻译、数据生成等方式增强数据集。</li><li><strong>语言特定的工具和资源</strong>：利用针对特定语言开发的分词器、解析器、词典和知识库，提高处理精度。</li><li><strong>社区和开源资源</strong>：参与多语言NLP社区，利用现有的开源工具和数据集，加速开发过程。</li></ol><hr><p>希望以上内容能帮助您理解在处理不同语言的自然语言处理任务时，哪些阶段需要针对语言特性进行调整，哪些阶段可以采用通用的方法。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在自然语言处理（NLP）中，处理不同语言时，某些阶段会有所不同，而其他阶段则基本相同。以下是对这些相同和不同阶段的详细说明：&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;相同或类似的阶段：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;任务定义和问题建模：&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>java web项目技术栈介绍</title>
    <link href="https://kryptonzy.github.io/blog/2024/09/02/JAVA%20WEB%E9%A1%B9%E7%9B%AE%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    <id>https://kryptonzy.github.io/blog/2024/09/02/JAVA%20WEB%E9%A1%B9%E7%9B%AE%E6%8A%80%E6%9C%AF%E6%A0%88/</id>
    <published>2024-09-02T08:31:44.294Z</published>
    <updated>2024-09-02T08:32:31.891Z</updated>
    
    <content type="html"><![CDATA[<p>你提供的配置文件片段涉及 <strong>Spring</strong>、<strong>Spring MVC</strong>、<strong>Spring Boot</strong>、<strong>Thymeleaf</strong>、<strong>JPA（Java Persistence API）</strong>、<strong>MyBatis</strong> 以及 <strong>Hibernate</strong> 等多个技术栈。接下来，我会逐一解释这些技术的关系，并给出它们的首次出现时间和应用背景。</p><h3 id="1-Spring-Framework"><a href="#1-Spring-Framework" class="headerlink" title="1. Spring Framework"></a>1. <strong>Spring Framework</strong></h3><ul><li><strong>首次出现时间</strong>：2003年（Spring Framework 1.0）</li><li><strong>应用背景</strong>：Spring 框架诞生于 2003 年，旨在简化 Java EE 开发中的复杂性。它通过提供依赖注入（DI）、面向切面编程（AOP）等特性，减少了代码的耦合度和冗余配置。</li><li><strong>关系</strong>：Spring 是所有这些技术栈的基础框架，为其他模块（如 Spring MVC）和工具（如 Spring Boot）提供了核心容器和依赖注入功能。Spring 也提供了与各种数据访问技术（如 JPA、MyBatis）的集成。</li></ul><h3 id="2-Spring-MVC"><a href="#2-Spring-MVC" class="headerlink" title="2. Spring MVC"></a>2. <strong>Spring MVC</strong></h3><ul><li><strong>首次出现时间</strong>：2004年（Spring Framework 1.2）</li><li><strong>应用背景</strong>：Spring MVC 是 Spring Framework 的一个模块，用于构建基于 Web 的应用程序。它采用 MVC（模型-视图-控制器）设计模式，旨在替代传统的 Java EE Web 框架，如 Struts，提供更灵活、更轻量级的 Web 开发支持。</li><li><strong>关系</strong>：Spring MVC 是 Spring 框架的一部分，用于处理 HTTP 请求和响应，是一个专门用于 Web 层的模块。Spring MVC 可以与 Thymeleaf 模板引擎集成来生成视图。</li></ul><h3 id="3-Spring-Boot"><a href="#3-Spring-Boot" class="headerlink" title="3. Spring Boot"></a>3. <strong>Spring Boot</strong></h3><ul><li><strong>首次出现时间</strong>：2014年（Spring Boot 1.0）</li><li><strong>应用背景</strong>：Spring Boot 是 Spring 团队推出的一个框架，旨在简化 Spring 应用的开发。它通过自动配置和约定优于配置的原则，减少了样板代码和复杂的 XML 配置，使开发者可以快速构建和运行 Spring 应用程序。</li><li><strong>关系</strong>：Spring Boot 基于 Spring 框架，提供了自动配置的能力，使得 Spring MVC、JPA、MyBatis 等与 Spring 框架的集成变得更加简单。你在配置文件中使用的 <code>application.yml</code> 正是 Spring Boot 项目中的配置文件。</li></ul><h3 id="4-Thymeleaf"><a href="#4-Thymeleaf" class="headerlink" title="4. Thymeleaf"></a>4. <strong>Thymeleaf</strong></h3><ul><li><strong>首次出现时间</strong>：2011年（Thymeleaf 1.0）</li><li><strong>应用背景</strong>：Thymeleaf 是一种现代的 Java 模板引擎，旨在替代 JSP（JavaServer Pages）等传统视图技术。它支持 HTML 5 并允许模板在浏览器和服务器端都能正常渲染，使得前端和后端开发更为流畅。</li><li><strong>关系</strong>：Thymeleaf 可以与 Spring MVC 配合使用，用于生成 HTML 页面。在 Spring Boot 中，Thymeleaf 已经集成好了，你只需要在 <code>application.yml</code> 中进行简单配置即可使用。</li></ul><h3 id="5-JPA（Java-Persistence-API）"><a href="#5-JPA（Java-Persistence-API）" class="headerlink" title="5. JPA（Java Persistence API）"></a>5. <strong>JPA（Java Persistence API）</strong></h3><ul><li><strong>首次出现时间</strong>：2006年（JPA 1.0，作为 EJB 3.0 规范的一部分）</li><li><strong>应用背景</strong>：JPA 是 Java 平台的官方持久化标准，它提供了一种对象关系映射（ORM）的方法来管理 Java 应用中的数据持久化。JPA 是 Java EE 5 规范的一部分，目的是为 Java 应用程序提供一个标准化的数据访问层。</li><li><strong>关系</strong>：JPA 是一个规范，Hibernate 是最常用的 JPA 实现之一。Spring Data JPA 是 Spring 提供的一个模块，它使得 JPA 的使用更加简单，结合 Spring Boot 提供的自动配置，开发者只需要定义接口和简单的注解即可完成数据访问逻辑。</li></ul><h3 id="6-MyBatis"><a href="#6-MyBatis" class="headerlink" title="6. MyBatis"></a>6. <strong>MyBatis</strong></h3><ul><li><strong>首次出现时间</strong>：2002年（最初作为 iBATIS 发布，2010 年更名为 MyBatis）</li><li><strong>应用背景</strong>：MyBatis 是一个支持自定义 SQL、存储过程以及高级映射的持久层框架。与 JPA 不同，MyBatis 提供了更高的灵活性，允许开发者手动编写 SQL 语句。它非常适合需要高性能 SQL 操作和复杂查询的场景。</li><li><strong>关系</strong>：MyBatis 可以作为 Spring 应用程序中的数据持久化解决方案之一。Spring Boot 可以通过自动配置轻松集成 MyBatis，你只需要配置 <code>mapper-locations</code> 和 <code>type-aliases-package</code> 等属性即可。</li></ul><h3 id="7-Hibernate"><a href="#7-Hibernate" class="headerlink" title="7. Hibernate"></a>7. <strong>Hibernate</strong></h3><ul><li><strong>首次出现时间</strong>：2001年（Hibernate 1.0）</li><li><strong>应用背景</strong>：Hibernate 是一个流行的 Java 持久层框架，提供了对象关系映射（ORM）的实现。它简化了数据库访问的复杂性，支持多种数据库，并与 JPA 规范兼容。Hibernate 最初由 Gavin King 开发，旨在替代 EJB 2.0。</li><li><strong>关系</strong>：Hibernate 是 JPA 的一种实现，你在配置文件中提到的 <code>database-platform</code> 是 Hibernate 用来生成 SQL 语句的方言。Spring 和 Spring Boot 通过 Spring Data JPA 模块原生支持 Hibernate 作为 JPA 的实现。</li></ul><h3 id="8-它们之间的关系总结"><a href="#8-它们之间的关系总结" class="headerlink" title="8. 它们之间的关系总结"></a>8. <strong>它们之间的关系总结</strong></h3><ul><li><strong>Spring Framework</strong>：核心基础框架，提供依赖注入（DI）和面向切面编程（AOP）功能，是整个 Spring 生态系统的核心。</li><li><strong>Spring MVC</strong>：Spring 的一个子模块，专门用于构建 Web 应用程序，它使用了 Spring 的核心功能。</li><li><strong>Spring Boot</strong>：构建于 Spring 之上，简化了 Spring 应用程序的开发和配置过程。它集成了 Spring MVC、Thymeleaf、JPA、MyBatis 等，使得所有这些技术可以更轻松地结合在一起。</li><li><strong>Thymeleaf</strong>：一个模板引擎，与 Spring MVC 一起使用来生成 Web 页面。</li><li><strong>JPA 和 Hibernate</strong>：JPA 是 Java 的持久化 API 规范，Hibernate 是它的一个常用实现。Spring Boot 可以自动配置这些工具，并使它们更容易使用。</li><li><strong>MyBatis</strong>：一个轻量级的持久化框架，提供了与 Spring 的紧密集成。与 JPA/Hibernate 的自动映射不同，MyBatis 允许开发者使用自定义 SQL 语句来操作数据库。</li></ul><h3 id="9-首次出现时间总结"><a href="#9-首次出现时间总结" class="headerlink" title="9. 首次出现时间总结"></a>9. <strong>首次出现时间总结</strong></h3><ul><li><strong>Spring Framework</strong>：2003年</li><li><strong>Spring MVC</strong>：2004年（Spring Framework 1.2 中发布）</li><li><strong>Spring Boot</strong>：2014年</li><li><strong>Thymeleaf</strong>：2011年</li><li><strong>JPA</strong>：2006年</li><li><strong>MyBatis</strong>：2002年（最初作为 iBATIS 发布）</li><li><strong>Hibernate</strong>：2001年</li></ul><p>这些技术在应用开发中各司其职，通过 Spring Boot 的简化配置，它们可以更加轻松地结合在一起，使得现代 Java 应用开发更加高效和灵活。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;你提供的配置文件片段涉及 &lt;strong&gt;Spring&lt;/strong&gt;、&lt;strong&gt;Spring MVC&lt;/strong&gt;、&lt;strong&gt;Spring Boot&lt;/strong&gt;、&lt;strong&gt;Thymeleaf&lt;/strong&gt;、&lt;strong&gt;JPA（Java</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>计组期末复习</title>
    <link href="https://kryptonzy.github.io/blog/2024/06/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    <id>https://kryptonzy.github.io/blog/2024/06/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</id>
    <published>2024-06-25T09:35:55.370Z</published>
    <updated>2024-06-27T12:33:01.966Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计组期末复习"><a href="#计组期末复习" class="headerlink" title="计组期末复习"></a>计组期末复习</h1><h2 id="《深入理解计算机系统》"><a href="#《深入理解计算机系统》" class="headerlink" title="《深入理解计算机系统》"></a>《深入理解计算机系统》</h2><h3 id="编译系统"><a href="#编译系统" class="headerlink" title="编译系统"></a>编译系统</h3><p>编译系统包括预处理器、编译器、汇编器、链接器四个程序。</p><h3 id="简单操作的例子"><a href="#简单操作的例子" class="headerlink" title="简单操作的例子"></a>简单操作的例子</h3><p>加载:从主存复制一个字节或者一个字到寄存器，以覆盖寄存器原来的内容。</p><p>存储:从寄存器复制一个字节或者一个字到主存的某个位置，以覆盖这个位置上原来的内容。</p><p>操作:把两个寄存器的内容复制到ALU，ALU对这两个字做算术运算，并将结果存放到一个寄存器中，以覆盖该寄存器中原来的内容。</p><p>跳转:从指令本身中抽取一个字，并将这个字复制到程序计数器(PC)中，以覆盖PC中原来的值。</p><div style="text-align: center"><img src="image/计算机组成原理/1719308673038.png" width="50%" height="50%" ></div><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程是操作系统对一个正在运行的程序的一种抽象</p><h3 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h3><p>上下文就是操作系统保持跟踪进程运行所需的而所有状态信息。</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>一个线程可以由多个成为线程的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。</p><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>虚拟内存是一个抽象概念，它为每个进程提供了一个假象，即每个进程都在独占地使用主存。每个进程看到的内存都是一致的，称为虚拟地址空间。</p><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>文件就是字节序列，仅此而已。</p><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>并发指的是一个同时具有多个活动的系统</p><h3 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h3><p>并行指的是用并发来使一个系统运行得更快</p><p>按照系统层次结构由高到低，有三个层次：线程级并发；指令级并行；单指令、多数据并行。</p><h3 id="超标量"><a href="#超标量" class="headerlink" title="超标量"></a>超标量</h3><p>如果处理器可以达到比一个周期一条指令更快的执行速率，就称之为超标量处理器。</p><h2 id="《杭电教材》"><a href="#《杭电教材》" class="headerlink" title="《杭电教材》"></a>《杭电教材》</h2><h3 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h3><h4 id="编址"><a href="#编址" class="headerlink" title="编址"></a>编址</h4><p>编址（Addressing）在计算机科学中是指为存储器中的每一个存储单元分配一个唯一的地址的过程。这个地址是一个数字标识符，CPU通过这个地址来定位和访问特定的存储单元。编址机制允许CPU知道数据或指令具体存储在哪里，从而能够读取或写入这些位置。</p><h4 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h4><p>主存由RAM和ROM组成。下面介绍RAM：</p><p>SRAM：每个存储单元有六个MOS管。</p><p>DRAM：每个存储单元有一个MOS管、一个电容。会“再生”、“刷新”。刷新分为：集中式刷新、分散式刷新、异步式刷新。</p><h5 id="主存与CPU的连接"><a href="#主存与CPU的连接" class="headerlink" title="主存与CPU的连接"></a>主存与CPU的连接</h5><p>存储容量有三种扩展方式：位扩展、字扩展、位字扩展。</p><h4 id="双端口存储器"><a href="#双端口存储器" class="headerlink" title="双端口存储器"></a>双端口存储器</h4><p>双端口存储器指同一个存储器具有两组相互独立的读写控制线路，允许两个独立的CPU或控制器同时异步地访问存储单元，是一种高速工作的存储器。</p><h4 id="多体交叉存储器"><a href="#多体交叉存储器" class="headerlink" title="多体交叉存储器"></a>多体交叉存储器</h4><p>多体交叉方式分为高位地址交叉方式（顺序编址）和低位地址交叉方式（交叉编址）。</p><h4 id="相联存储器"><a href="#相联存储器" class="headerlink" title="相联存储器"></a>相联存储器</h4><h4 id="高速缓冲存储器"><a href="#高速缓冲存储器" class="headerlink" title="高速缓冲存储器"></a>高速缓冲存储器</h4><p><strong>程序局部性原理</strong>：包括时间局部性、空间局部性。</p><p>Cache的材质是高速的SRAM</p><p><strong>Cache-主存系统：</strong> 小容量、高速度的Cache和由大容量、低速度的DRAM构成的主存储器组合起来。这样构成的系统。</p><p>Cache及其控制逻辑完全由硬件实现。</p><p>Cache的地址存放在一个相联存储器中，这个相联存储器的内容就是地址。当CPU提供字地址时，相联存储器按内容进行查找，如果地址匹配成功，则Cache有该数据的副本，称为<strong>Cache命中</strong>。反之则成为<strong>Cache不命中</strong>或<strong>Cache缺失</strong>。</p><p>Cache-主存系统的指标参数：命中率、平均访问时间、访问效率。</p><p>Cache的透明性：地址映射完全由硬件实现，软件人员丝毫感受不到Cache的存在。</p><p>主存地址与Cache的地址映射方式有三种：直接映射、全相联映射、组相联映射。</p><p>替换算法：随机替换算法、先进先出算法（FIFO）、最近最少使用算法（LRU）</p><p>写策略：写贯穿策略、写回策略</p><h3 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h3><h3 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h3><p>一个指令包含若干个机器周期（CPU周期），一个机器周期包含若干个时钟周期（节拍、T周期、CPU时钟周期）</p><h3 id="为什么选择多周期CPU而不选择单周期CPU"><a href="#为什么选择多周期CPU而不选择单周期CPU" class="headerlink" title="为什么选择多周期CPU而不选择单周期CPU"></a>为什么选择多周期CPU而不选择单周期CPU</h3><p>虽然单周期CPU在每个时钟周期内完成一条指令，使得CPI（每条指令的时钟周期数）等于1，从而看似简化了设计和实现，但在实践中，多周期CPU通常更为常见。这是因为多周期CPU有许多优势，使其在性能和效率上更具吸引力。下面是多周期CPU相对于单周期CPU的一些主要优势和原因：</p><h4 id="1-时钟周期时间更短"><a href="#1-时钟周期时间更短" class="headerlink" title="1. 时钟周期时间更短"></a>1. 时钟周期时间更短</h4><ul><li><strong>单周期CPU</strong>：必须保证所有指令在一个时钟周期内完成。这意味着时钟周期必须足够长，以容纳执行时间最长的指令。</li><li><strong>多周期CPU</strong>：每条指令分为多个步骤，每个步骤在一个时钟周期内完成。这使得时钟周期可以缩短，因为每个步骤的执行时间通常比最长指令的执行时间短得多。</li></ul><h4 id="2-硬件利用效率更高"><a href="#2-硬件利用效率更高" class="headerlink" title="2. 硬件利用效率更高"></a>2. 硬件利用效率更高</h4><ul><li><strong>单周期CPU</strong>：所有指令在一个时钟周期内完成，意味着所有硬件资源（如ALU、寄存器）在每个时钟周期内都必须准备好处理最复杂的指令。这导致了硬件资源在处理简单指令时的低效利用。</li><li><strong>多周期CPU</strong>：不同指令的不同步骤在不同的时钟周期内完成，使得硬件资源可以更均匀地分布在多个时钟周期内利用，提高了整体硬件利用率。</li></ul><h4 id="3-指令集扩展和复杂性管理"><a href="#3-指令集扩展和复杂性管理" class="headerlink" title="3. 指令集扩展和复杂性管理"></a>3. 指令集扩展和复杂性管理</h4><ul><li><strong>单周期CPU</strong>：由于所有指令在一个时钟周期内完成，复杂指令的引入会显著增加时钟周期时间，限制了指令集的扩展。</li><li><strong>多周期CPU</strong>：允许复杂指令分解为多个步骤执行，每个步骤在一个时钟周期内完成。这使得设计者可以更灵活地引入复杂指令而不显著影响时钟周期时间。</li></ul><h4 id="4-电能消耗"><a href="#4-电能消耗" class="headerlink" title="4. 电能消耗"></a>4. 电能消耗</h4><ul><li><strong>单周期CPU</strong>：较长的时钟周期时间和较高的硬件要求会增加功耗，特别是在处理简单指令时效率低下。</li><li><strong>多周期CPU</strong>：由于更短的时钟周期时间和更高的硬件利用率，多周期CPU通常在电能消耗方面更为高效。</li></ul><h4 id="5-性能优化"><a href="#5-性能优化" class="headerlink" title="5. 性能优化"></a>5. 性能优化</h4><ul><li><strong>单周期CPU</strong>：时钟周期时间被最长指令所限制，导致整体性能优化困难。</li><li><strong>多周期CPU</strong>：通过优化每个步骤的执行时间和流水线设计，可以更有效地提高性能。例如，可以通过增加流水线深度来并行处理更多指令。</li></ul><h4 id="6-设计复杂性和灵活性"><a href="#6-设计复杂性和灵活性" class="headerlink" title="6. 设计复杂性和灵活性"></a>6. 设计复杂性和灵活性</h4><ul><li><strong>单周期CPU</strong>：设计较为简单，但在面对复杂指令集时变得困难。</li><li><strong>多周期CPU</strong>：设计较为复杂，但提供了更大的灵活性来处理复杂指令集和优化性能。</li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>假设有一条复杂的指令需要5个子操作才能完成：</p><ul><li>在单周期CPU中，时钟周期时间必须足够长以容纳所有5个子操作的执行时间，这会拖慢其他所有指令的执行。</li><li>在多周期CPU中，可以将这条指令分解为5个步骤，每个步骤在一个时钟周期内完成，允许时钟周期时间缩短并提高整体效率。</li></ul><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>尽管单周期CPU设计相对简单，并能在一个时钟周期内完成一条指令，但在实际应用中，多周期CPU通过更短的时钟周期时间、更高的硬件利用率、更灵活的指令集扩展和更有效的性能优化，提供了更高的效率和性能。因此，多周期CPU在现代计算机设计中更为常见。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;计组期末复习&quot;&gt;&lt;a href=&quot;#计组期末复习&quot; class=&quot;headerlink&quot; title=&quot;计组期末复习&quot;&gt;&lt;/a&gt;计组期末复习&lt;/h1&gt;&lt;h2 id=&quot;《深入理解计算机系统》&quot;&gt;&lt;a href=&quot;#《深入理解计算机系统》&quot; class=&quot;header</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>多模态</title>
    <link href="https://kryptonzy.github.io/blog/2024/06/20/%E5%A4%9A%E6%A8%A1%E6%80%81/"/>
    <id>https://kryptonzy.github.io/blog/2024/06/20/%E5%A4%9A%E6%A8%A1%E6%80%81/</id>
    <published>2024-06-20T09:28:02.857Z</published>
    <updated>2024-06-20T09:32:52.450Z</updated>
    
    <content type="html"><![CDATA[<p>在训练多模态模型时，确实会用到多种类型的数据，例如图像、文本、音频等。这些数据的组合可以帮助模型学到更丰富的特征表示。然而，在推理阶段是否需要多模态数据则取决于模型的设计和具体应用场景。</p><h3 id="推理阶段对多模态数据的需求"><a href="#推理阶段对多模态数据的需求" class="headerlink" title="推理阶段对多模态数据的需求"></a>推理阶段对多模态数据的需求</h3><ol><li><p><strong>需要多模态数据的情况</strong>:</p><ul><li><strong>模型设计需要多模态输入</strong>：如果训练的模型本身设计成需要同时输入多种模态数据（例如图像和文本），那么在推理时也需要相应的多模态数据来进行预测。例如，一个结合图像和文本信息来生成描述的模型，需要同时输入图像和文本才能生成准确的描述。</li><li><strong>任务本身是多模态的</strong>：某些任务本身就是多模态的，例如视频字幕生成（需要视频和音频数据）、跨模态检索（需要图像和文本数据）等。这类任务在推理阶段自然也需要多模态的数据输入。</li></ul></li><li><p><strong>不需要多模态数据的情况</strong>:</p><ul><li><strong>单模态输出模型</strong>：有些多模态模型在训练时用到了多模态数据，但在推理时只需要单一模态的输入即可。例如，一个利用文本和图像数据训练的情感分析模型，在推理时可能只需要文本数据就可以进行情感分类。</li><li><strong>多模态数据融合后进行单模态推理</strong>：有些模型在训练阶段使用多模态数据进行融合，学习到的表示可以在推理阶段仅通过单一模态数据进行推理。例如，一个通过图像和文本联合训练的模型，可能通过学习到的图像特征在推理阶段仅输入图像数据就能完成任务。</li></ul></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>推理阶段是否需要多模态数据主要取决于模型的设计和任务需求。了解具体模型的工作机制和应用场景，可以帮助确定在推理阶段是否需要准备多种模态的数据输入。</p><p>一个典型的例子是通过多模态数据（例如图像和文本）训练的视觉问答（Visual Question Answering, VQA）模型，但在推理阶段只需要单一模态的数据（例如文本）即可进行推理。</p><h3 id="例子：视觉问答（VQA）模型"><a href="#例子：视觉问答（VQA）模型" class="headerlink" title="例子：视觉问答（VQA）模型"></a>例子：视觉问答（VQA）模型</h3><p><strong>训练阶段</strong>：</p><ol><li><p><strong>数据准备</strong>：</p><ul><li>图像数据：包含大量的图像，如COCO数据集。</li><li>文本数据：对应图像的自然语言问题和答案。</li></ul></li><li><p><strong>模型架构</strong>：</p><ul><li><strong>图像特征提取</strong>：使用预训练的卷积神经网络（如ResNet）提取图像的特征向量。</li><li><strong>文本特征提取</strong>：使用预训练的语言模型（如BERT）提取问题的特征向量。</li><li><strong>多模态融合</strong>：将图像特征和文本特征通过某种方式（如注意力机制或简单的拼接）进行融合，形成一个联合特征表示。</li><li><strong>分类器</strong>：将融合后的特征输入到一个全连接层或其他分类器，预测答案。</li></ul></li><li><p><strong>训练过程</strong>：</p><ul><li>利用图像和文本数据的联合表示，训练模型在给定图像和问题的情况下，生成正确的答案。</li></ul></li></ol><p><strong>推理阶段</strong>：</p><ol><li><p><strong>输入文本数据</strong>：</p><ul><li>在推理阶段，只提供文本数据，即自然语言问题，而不再需要图像数据。</li></ul></li><li><p><strong>模型推理</strong>：</p><ul><li>由于模型在训练阶段已经通过多模态数据学到了丰富的特征表示，它能够在只提供问题的情况下，通过内在的特征和知识进行推理，生成合理的答案。</li></ul></li></ol><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>假设我们有以下训练数据：</p><ul><li>图像：一张显示一只猫坐在沙发上的照片。</li><li>问题：这张照片里有什么动物？</li><li>答案：猫。</li></ul><p>在训练阶段，模型通过图像和问题的联合表示，学会了在看到类似图像和相关问题时，能够正确地回答“猫”。</p><p>在推理阶段，我们只提供问题：</p><ul><li>问题：这张照片里有什么动物？</li></ul><p>由于模型在训练阶段已经学到了与图像和问题相关的特征，即使在没有图像的情况下，它也能根据问题的内容和训练中学到的知识，合理地猜测答案是“猫”。</p><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>这种方法适用于模型能够在训练阶段充分利用多模态数据学习到足够多的特征和知识，并在推理阶段根据部分模态的数据进行有效推理的情况。这类模型在训练阶段的多模态数据融合可以显著提升推理能力，即使在推理阶段缺少部分模态数据，也能够提供可靠的输出。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在训练多模态模型时，确实会用到多种类型的数据，例如图像、文本、音频等。这些数据的组合可以帮助模型学到更丰富的特征表示。然而，在推理阶段是否需要多模态数据则取决于模型的设计和具体应用场景。&lt;/p&gt;
&lt;h3 id=&quot;推理阶段对多模态数据的需求&quot;&gt;&lt;a href=&quot;#推理阶段对多</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>java初步</title>
    <link href="https://kryptonzy.github.io/blog/2024/06/16/JAVA%E5%88%9D%E6%AD%A5/"/>
    <id>https://kryptonzy.github.io/blog/2024/06/16/JAVA%E5%88%9D%E6%AD%A5/</id>
    <published>2024-06-16T11:30:33.370Z</published>
    <updated>2024-06-17T02:17:39.186Z</updated>
    
    <content type="html"><![CDATA[<p>当然可以，我可以解释这些文件及其之间的关系。</p><h3 id="1-controller-包"><a href="#1-controller-包" class="headerlink" title="1. controller 包"></a>1. <code>controller</code> 包</h3><ul><li><strong><code>AdminController</code></strong> 和 <strong><code>UserController</code></strong>:<br>这些是控制器类，负责处理HTTP请求并返回响应。<code>AdminController</code>通常处理管理员相关的请求，而 <code>UserController</code>处理用户相关的请求。控制器类使用注解（如 <code>@GetMapping</code>, <code>@PostMapping</code>等）来映射请求URL。</li></ul><h3 id="2-entity-包"><a href="#2-entity-包" class="headerlink" title="2. entity 包"></a>2. <code>entity</code> 包</h3><ul><li><strong><code>User</code></strong>, <strong><code>Order</code></strong>, <strong><code>Evaluation</code></strong>, <strong><code>Maintenance</code></strong>:<br>这些是实体类，代表数据库中的表结构。每个实体类对应数据库中的一个表，类中的属性对应表中的列。这些类通常带有getter和setter方法，用于访问和修改属性。</li></ul><h3 id="3-mapper-包"><a href="#3-mapper-包" class="headerlink" title="3. mapper 包"></a>3. <code>mapper</code> 包</h3><ul><li><strong><code>AdminMapper</code></strong> 和 <strong><code>UserMapper</code></strong>:<br>这些是MyBatis的Mapper接口，负责定义数据库操作的方法。这些接口通过注解或XML配置文件中的SQL语句与数据库交互。<code>UserMapper</code>负责用户相关的数据库操作，而 <code>AdminMapper</code>负责管理员相关的数据库操作。</li></ul><h3 id="4-service-包"><a href="#4-service-包" class="headerlink" title="4. service 包"></a>4. <code>service</code> 包</h3><ul><li><strong><code>AdminService</code></strong> 和 <strong><code>UserService</code></strong>:<br>这些是服务类，包含业务逻辑。<code>UserService</code>负责用户相关的业务逻辑，而 <code>AdminService</code>负责管理员相关的业务逻辑。服务类通过自动装配（如 <code>@Autowired</code>）使用Mapper接口或Repository接口与数据库交互。</li></ul><h3 id="5-Demo2Application-类"><a href="#5-Demo2Application-类" class="headerlink" title="5. Demo2Application 类"></a>5. <code>Demo2Application</code> 类</h3><p>这是Spring Boot应用的启动类，带有 <code>@SpringBootApplication</code>注解。它包含 <code>main</code>方法，用于启动Spring Boot应用。</p><h3 id="文件关系总结"><a href="#文件关系总结" class="headerlink" title="文件关系总结"></a>文件关系总结</h3><ol><li><p><strong>控制器 (Controller)</strong>：</p><ul><li>接收HTTP请求。</li><li>调用服务类中的方法处理业务逻辑。</li><li>返回视图或响应数据。</li></ul></li><li><p><strong>服务 (Service)</strong>：</p><ul><li>包含业务逻辑。</li><li>调用Mapper或Repository接口与数据库交互。</li></ul></li><li><p><strong>实体 (Entity)</strong>：</p><ul><li>代表数据库表结构。</li><li>在服务和控制器之间传递数据。</li></ul></li><li><p><strong>Mapper</strong>：</p><ul><li>负责数据库操作。</li><li>Mapper接口使用MyBatis框架。</li></ul></li></ol><p>这些组件共同协作，构成了一个典型的Spring Boot应用程序，处理从接收请求到返回响应的整个流程。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;当然可以，我可以解释这些文件及其之间的关系。&lt;/p&gt;
&lt;h3 id=&quot;1-controller-包&quot;&gt;&lt;a href=&quot;#1-controller-包&quot; class=&quot;headerlink&quot; title=&quot;1. controller 包&quot;&gt;&lt;/a&gt;1. &lt;code&gt;cont</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>富文本格式</title>
    <link href="https://kryptonzy.github.io/blog/2024/06/14/%E6%96%87%E6%9C%AC%E6%A0%BC%E5%BC%8F/"/>
    <id>https://kryptonzy.github.io/blog/2024/06/14/%E6%96%87%E6%9C%AC%E6%A0%BC%E5%BC%8F/</id>
    <published>2024-06-14T08:16:54.887Z</published>
    <updated>2024-06-14T11:27:08.167Z</updated>
    
    <content type="html"><![CDATA[<p><strong>富文本格式（Rich Text Format）即RTF格式，又称多文本格式，是由</strong><a href="https://baike.baidu.com/item/%E5%BE%AE%E8%BD%AF/124767?fromModule=lemma_inlink">微软</a>公司开发的<a href="https://baike.baidu.com/item/%E8%B7%A8%E5%B9%B3%E5%8F%B0/8558902?fromModule=lemma_inlink">跨平台</a>文档格式。大多数的<a href="https://baike.baidu.com/item/%E6%96%87%E5%AD%97%E5%A4%84%E7%90%86%E8%BD%AF%E4%BB%B6/4719058?fromModule=lemma_inlink">文字处理软件</a>都能读取和保存RTF文档。它是一种方便于不同的设备、系统查看的文本和图形文档格式。它允许文本包含多种样式和格式，如加粗、斜体、下划线、颜色、字体大小、列表、链接、图片等。这种格式使得文本内容更加丰富和具有吸引力，同时便于阅读和理解。</p><p>富文本格式通常使用HTML（HyperText Markup Language）或者富文本编辑器（如TinyMCE、CKEditor等）来实现。HTML是网页的标准标记语言，它使用标签来定义文本的格式和样式。例如：</p><ul><li><code>&lt;b&gt;</code> 标签用于加粗文本。</li><li><code>&lt;i&gt;</code> 标签用于斜体文本。</li><li><code>&lt;u&gt;</code> 标签用于下划线文本。</li><li><code>&lt;a href=&quot;URL&quot;&gt;</code> 标签用于创建超链接。</li><li><code>&lt;img src=&quot;image_url&quot;&gt;</code> 标签用于插入图片。</li></ul><p>富文本编辑器提供了一个用户友好的界面，允许用户通过拖放、点击按钮或使用快捷键来应用各种格式和样式，而无需直接编写HTML代码。</p><p>富文本格式的优势包括：</p><ol><li><strong>增强的可读性</strong>：通过不同的字体、大小和颜色，可以突出显示重要信息。</li><li><strong>视觉吸引力</strong>：丰富的格式和样式可以吸引读者的注意力。</li><li><strong>结构化内容</strong>：列表、标题和段落等可以清晰地组织内容。</li><li><strong>交互性</strong>：可以包含链接、按钮和其他交互元素。</li></ol><p>然而，富文本格式也有其局限性，比如在不同的浏览器或设备上可能会显示不一致，以及在不支持富文本的平台上可能无法正确显示。</p><p>在编写富文本时，重要的是要确保内容的可访问性，比如为图片提供替代文本（alt text），以及确保内容在没有样式的情况下仍然易于阅读。</p><p>与富文本格式相关的一些概念包括：</p><ol><li><strong>HTML (HyperText Markup Language)</strong> ：一种用于创建网页的标准标记语言，它允许定义文本的结构和样式。</li><li><strong>CSS (Cascading Style Sheets)</strong> ：用于控制网页的布局和外观的样式表语言，可以与HTML结合使用来增强富文本的视觉效果。</li><li><strong>JavaScript</strong> ：一种脚本语言，用于创建动态的网页元素，可以与HTML和CSS一起使用，为富文本添加交互性。</li><li><strong>DOM (Document Object Model)</strong> ：一种编程接口，用于HTML和XML文档。它将文档呈现为一个树形结构，使得JavaScript可以动态地访问和修改页面内容。</li><li><strong>WYSIWYG (What You See Is What You Get)</strong> ：所见即所得编辑器，允许用户在编辑时看到最终的排版效果，常用于富文本编辑器。</li><li><strong>Markdown</strong> ：一种轻量级标记语言，用于格式化文本，它使用简单的标记符号来表示不同的格式，但不如富文本格式那样丰富。</li><li><strong>Rich Text Editor</strong> ：富文本编辑器，是一种软件组件，允许用户以所见即所得的方式编辑富文本内容。</li><li><strong>ContentEditable</strong> ：HTML中的一个属性，当设置为true时，可以使网页元素成为可编辑的富文本区域。</li><li><strong>ARIA (Accessible Rich Internet Applications)</strong> ：一种用于提高Web应用可访问性的技术，通过提供额外的语义信息来帮助辅助技术理解富文本内容。</li><li><strong>Semantic HTML</strong> ：语义化HTML，使用具有明确意义的HTML标签来组织内容，有助于搜索引擎优化和辅助技术的理解。</li><li><strong>Responsive Web Design</strong> ：响应式网页设计，确保网页在不同设备和屏幕尺寸上都能正确显示，富文本格式在响应式设计中也应保持一致性。</li><li><strong>Cross-Browser Compatibility</strong> ：跨浏览器兼容性，确保网页在不同的浏览器上都能正确显示和工作，包括富文本格式。</li><li><strong>Web Accessibility</strong> ：网页可访问性，确保所有用户，包括残障人士，都能访问和使用网页内容，富文本格式应遵循可访问性指南。</li><li><strong>Text-to-Speech (TTS)</strong> ：文本到语音技术，可以将文本内容转换为语音，对于富文本格式，TTS技术需要能够正确解析和朗读文本格式。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;富文本格式（Rich Text Format）即RTF格式，又称多文本格式，是由&lt;/strong&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E5%BE%AE%E8%BD%AF/124767?fromModule=lemma</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>深度学习总结</title>
    <link href="https://kryptonzy.github.io/blog/2024/06/14/%E7%82%BC%E4%B8%B9/"/>
    <id>https://kryptonzy.github.io/blog/2024/06/14/%E7%82%BC%E4%B8%B9/</id>
    <published>2024-06-14T07:36:47.210Z</published>
    <updated>2024-06-18T17:05:44.869Z</updated>
    
    <content type="html"><![CDATA[<h2 id="深度学习项目流程"><a href="#深度学习项目流程" class="headerlink" title="深度学习项目流程"></a>深度学习项目流程</h2><p>完成一个深度学习项目通常包括以下几个步骤，每个步骤都需要仔细规划和执行：</p><h3 id="1-项目定义与目标设定"><a href="#1-项目定义与目标设定" class="headerlink" title="1. 项目定义与目标设定"></a>1. <strong>项目定义与目标设定</strong></h3><ul><li><strong>确定问题</strong>：明确要解决的具体问题或任务（例如图像分类、对象检测、自然语言处理等）。</li><li><strong>设定目标</strong>：定义项目的具体目标和成功标准（例如达到某个准确率、缩短处理时间等）。</li></ul><h3 id="2-数据收集与准备"><a href="#2-数据收集与准备" class="headerlink" title="2. 数据收集与准备"></a>2. <strong>数据收集与准备</strong></h3><ul><li><strong>数据收集</strong>：从公开数据集、传感器、日志文件等渠道获取相关数据。</li><li><strong>数据清洗</strong>：处理缺失数据、异常值、重复数据等，确保数据质量。</li><li><strong>数据标注</strong>：根据项目需求对数据进行标注（例如图像的分类标签、对象的边界框等）。</li><li><strong>数据分割</strong>：将数据集分为训练集、验证集和测试集，通常按照8:1:1的比例进行分割。</li></ul><h3 id="3-探索性数据分析-EDA"><a href="#3-探索性数据分析-EDA" class="headerlink" title="3. 探索性数据分析 (EDA)"></a>3. <strong>探索性数据分析 (EDA)</strong></h3><ul><li><strong>数据可视化</strong>：使用图表和统计分析工具了解数据分布和特征。</li><li><strong>特征工程</strong>：提取、选择和创建新的特征，以提高模型的性能。</li></ul><h3 id="4-选择和设计模型"><a href="#4-选择和设计模型" class="headerlink" title="4. 选择和设计模型"></a>4. <strong>选择和设计模型</strong></h3><ul><li><strong>选择算法</strong>：根据任务性质选择合适的深度学习算法（例如卷积神经网络CNN、循环神经网络RNN、Transformer等）。</li><li><strong>设计模型架构</strong>：设计模型的具体结构，包括层数、每层的神经元数、激活函数等。</li></ul><h3 id="5-模型训练"><a href="#5-模型训练" class="headerlink" title="5. 模型训练"></a>5. <strong>模型训练</strong></h3><ul><li><strong>定义损失函数和优化器</strong>：选择合适的损失函数（例如交叉熵损失、均方误差等）和优化器（例如SGD、Adam等）。</li><li><strong>超参数调整</strong>：通过网格搜索或随机搜索等方法调整模型的超参数（例如学习率、批次大小等）。</li><li><strong>模型训练</strong>：使用训练数据进行模型训练，并在验证集上评估模型性能，调整模型参数。</li></ul><h3 id="6-模型评估与调优"><a href="#6-模型评估与调优" class="headerlink" title="6. 模型评估与调优"></a>6. <strong>模型评估与调优</strong></h3><ul><li><strong>性能评估</strong>：使用测试集评估模型的最终性能（例如准确率、召回率、F1分数等）。</li><li><strong>模型调优</strong>：根据评估结果进一步调优模型，可能需要重新进行特征工程、调整模型架构或超参数。</li></ul><h3 id="7-模型部署"><a href="#7-模型部署" class="headerlink" title="7. 模型部署"></a>7. <strong>模型部署</strong></h3><ul><li><strong>选择部署环境</strong>：确定模型的部署环境（例如云端、边缘设备、移动设备等）。</li><li><strong>模型导出</strong>：将模型导出为适合部署的格式（例如ONNX、TensorFlow Lite等）。</li><li><strong>部署实施</strong>：将模型部署到实际环境中，并进行集成测试。</li></ul><h3 id="8-模型监控与维护"><a href="#8-模型监控与维护" class="headerlink" title="8. 模型监控与维护"></a>8. <strong>模型监控与维护</strong></h3><ul><li><strong>性能监控</strong>：持续监控模型的性能，确保模型在实际应用中的表现。</li><li><strong>模型更新</strong>：根据实际需求定期更新模型，处理数据漂移、模型老化等问题。</li></ul><h3 id="9-项目总结与文档编写"><a href="#9-项目总结与文档编写" class="headerlink" title="9. 项目总结与文档编写"></a>9. <strong>项目总结与文档编写</strong></h3><ul><li><strong>总结报告</strong>：撰写项目总结报告，包含问题定义、数据处理、模型设计、训练过程、性能评估、部署和维护等内容。</li><li><strong>文档编写</strong>：撰写详细的技术文档，便于后续的维护和二次开发。</li></ul><p>每个步骤都可能需要反复迭代，根据具体项目的需求和挑战不断调整和优化。</p><h2 id="推理（Inference）和测试（Testing）分别属于深度学习项目流程中的不同部分："><a href="#推理（Inference）和测试（Testing）分别属于深度学习项目流程中的不同部分：" class="headerlink" title="推理（Inference）和测试（Testing）分别属于深度学习项目流程中的不同部分："></a>推理（Inference）和测试（Testing）分别属于深度学习项目流程中的不同部分：</h2><h3 id="流程中的推理（Inference）"><a href="#流程中的推理（Inference）" class="headerlink" title="流程中的推理（Inference）"></a>流程中的推理（Inference）</h3><p>推理属于 <strong>模型部署</strong> 这一部分。推理是指将训练好的模型应用于实际场景，对新数据进行预测和分类的过程。推理通常发生在模型已经通过测试和验证，并正式上线部署之后。</p><p>在项目流程中，推理的具体步骤包括：</p><ol><li><strong>选择部署环境</strong> ：确定模型的部署环境（如云端、边缘设备、移动设备等）。</li><li><strong>模型导出</strong> ：将模型导出为适合部署的格式（如 ONNX、TensorFlow Lite 等）。</li><li><strong>部署实施</strong> ：将模型部署到实际环境中，并进行集成测试。</li><li><strong>实时预测</strong> ：使用模型对实际应用中的新数据进行预测。</li></ol><h3 id="流程中的测试（Testing）"><a href="#流程中的测试（Testing）" class="headerlink" title="流程中的测试（Testing）"></a>流程中的测试（Testing）</h3><p>测试属于 <strong>模型评估与调优</strong> 这一部分。测试是通过使用独立的测试数据集来评估模型性能的过程，以验证模型的泛化能力和准确性。测试通常在模型训练完成后进行，是评估和验证模型效果的关键步骤。</p><p>在项目流程中，测试的具体步骤包括：</p><ol><li><strong>性能评估</strong> ：使用测试集评估模型的最终性能（如准确率、召回率、F1 分数等）。</li><li><strong>指标计算</strong> ：计算各种性能指标，以分析和比较模型。</li><li><strong>模型调优</strong> ：根据评估结果进一步调优模型，可能需要重新进行特征工程、调整模型架构或超参数。</li><li><strong>模型选择</strong> ：根据测试结果选择最佳模型，准备进行部署。</li></ol><h2 id="如何改进模型的性能"><a href="#如何改进模型的性能" class="headerlink" title="如何改进模型的性能"></a>如何改进模型的性能</h2><h3 id="1-调整模型架构"><a href="#1-调整模型架构" class="headerlink" title="1. 调整模型架构"></a>1. 调整模型架构</h3><p>尝试增加或减少LSTM单元的数量，添加更多的LSTM层或其他类型的层（如GRU），以探索最适合你数据的模型架构。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">model = Sequential()</span><br><span class="line">model.add(LSTM(<span class="number">128</span>, return_sequences=<span class="literal">True</span>, input_shape=(time_steps, <span class="number">4</span>)))  <span class="comment"># 增加LSTM单元数量</span></span><br><span class="line">model.add(Dropout(<span class="number">0.2</span>))</span><br><span class="line">model.add(LSTM(<span class="number">64</span>, return_sequences=<span class="literal">True</span>))</span><br><span class="line">model.add(Dropout(<span class="number">0.2</span>))</span><br><span class="line">model.add(LSTM(<span class="number">32</span>))  <span class="comment"># 增加LSTM层</span></span><br><span class="line">model.add(Dropout(<span class="number">0.2</span>))</span><br><span class="line">model.add(Dense(<span class="number">1</span>))</span><br></pre></td></tr></table></figure><h3 id="2-调整超参数"><a href="#2-调整超参数" class="headerlink" title="2. 调整超参数"></a>2. 调整超参数</h3><p>可以尝试调整学习率、batch size和dropout率。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> keras.optimizers <span class="keyword">import</span> Adam</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调整学习率</span></span><br><span class="line">optimizer = Adam(learning_rate=<span class="number">0.001</span>)  <span class="comment"># 默认0.001，可以尝试更低或更高的学习率</span></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=optimizer, loss=<span class="string">&#x27;mean_squared_error&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="3-增加训练轮数（epochs）"><a href="#3-增加训练轮数（epochs）" class="headerlink" title="3. 增加训练轮数（epochs）"></a>3. 增加训练轮数（epochs）</h3><p>虽然当前的训练轮数是50，你可以尝试增加训练轮数以确保模型充分训练。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">history = model.fit(X_train, y_train, epochs=<span class="number">100</span>, batch_size=<span class="number">32</span>, validation_data=(X_test, y_test))  <span class="comment"># 增加epochs</span></span><br></pre></td></tr></table></figure><h3 id="4-使用早停法（Early-Stopping）"><a href="#4-使用早停法（Early-Stopping）" class="headerlink" title="4. 使用早停法（Early Stopping）"></a>4. 使用早停法（Early Stopping）</h3><p>早停法可以在验证损失不再下降时提前停止训练，防止过拟合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> keras.callbacks <span class="keyword">import</span> EarlyStopping</span><br><span class="line"></span><br><span class="line">early_stopping = EarlyStopping(monitor=<span class="string">&#x27;val_loss&#x27;</span>, patience=<span class="number">10</span>, restore_best_weights=<span class="literal">True</span>)</span><br><span class="line">history = model.fit(X_train, y_train, epochs=<span class="number">100</span>, batch_size=<span class="number">32</span>, validation_data=(X_test, y_test), callbacks=[early_stopping])</span><br></pre></td></tr></table></figure><h3 id="5-数据归一化"><a href="#5-数据归一化" class="headerlink" title="5. 数据归一化"></a>5. 数据归一化</h3><p>确保你的数据已经归一化，可以使用MinMaxScaler或StandardScaler进行数据标准化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> MinMaxScaler</span><br><span class="line"></span><br><span class="line">scaler = MinMaxScaler()</span><br><span class="line">data_normalized = scaler.fit_transform(data)</span><br></pre></td></tr></table></figure><h3 id="6-数据增强"><a href="#6-数据增强" class="headerlink" title="6. 数据增强"></a>6. 数据增强</h3><p>如果数据量较小，可以尝试进行数据增强（例如时间序列数据的滑动窗口法）。</p><h3 id="7-交叉验证"><a href="#7-交叉验证" class="headerlink" title="7. 交叉验证"></a>7. 交叉验证</h3><p>使用交叉验证来评估模型的泛化性能，确保模型在不同数据集上的表现一致。</p><h2 id="相关参数介绍"><a href="#相关参数介绍" class="headerlink" title="相关参数介绍"></a>相关参数介绍</h2><p><img src="image/炼丹/1718358412998.png" alt="1718358412998"></p><p>这张图片显示了在一个训练和验证过程中各项损失函数和评估指标的变化情况，共包含八个图表。以下是每个图表的具体信息：</p><ol><li><strong>train/box_loss</strong>：这是训练过程中框损失（box loss）的变化曲线。从图中可以看到，随着训练轮次的增加，框损失逐渐降低。</li><li><strong>train/cls_loss</strong>：这是训练过程中分类损失（classification loss）的变化曲线。从图中可以看到，分类损失在训练初期急剧下降，随后逐渐趋于平稳。</li><li><strong>train/dfl_loss</strong>：这是训练过程中分布聚焦损失（distribution focal loss）的变化曲线。图中显示该损失在逐渐下降。</li><li><strong>metrics/precision</strong>：这是训练过程中精度（precision）的变化曲线。图中显示精度在训练过程中有所波动，但整体趋势是上升的。</li><li><strong>metrics/recall</strong>：这是训练过程中召回率（recall）的变化曲线。图中显示召回率逐渐上升，表明模型在训练过程中对目标的识别能力不断增强。</li><li><strong>val/box_loss</strong>：这是验证过程中框损失的变化曲线。从图中可以看到，框损失在验证集上的表现有所波动，但总体趋势是下降的。</li><li><strong>val/cls_loss</strong>：这是验证过程中分类损失的变化曲线。图中显示分类损失在验证集上的表现也有所波动，但总体趋势是下降的。</li><li><strong>val/dfl_loss</strong>：这是验证过程中分布聚焦损失的变化曲线。图中显示该损失在验证集上逐渐下降。</li><li><strong>metrics/mAP_0.5</strong>：这是验证过程中平均精度（mean Average Precision，mAP）在IOU阈值为0.5时的变化曲线。图中显示mAP值逐渐上升，表明模型的检测精度在不断提高。</li><li><strong>metrics/mAP_0.5:0.95</strong>：这是验证过程中平均精度在不同IOU阈值（从0.5到0.95）下的变化曲线。图中显示该指标逐渐上升，表明模型在不同IOU阈值下的检测精度均有提高。</li></ol><p>这些图表展示了模型在训练和验证过程中不同损失函数和评估指标的变化情况，反映了模型训练效果的逐步提升。</p><h2 id="训练策略"><a href="#训练策略" class="headerlink" title="训练策略"></a>训练策略</h2><p>在深度学习模型训练过程中，学习率的设置和数据增强策略的调整对模型性能有着至关重要的影响。下面详细解释在YOLOv9训练过程中采用线性预热学习率和关闭拼接数据增强（mosaic data augmentation）的原因。</p><h3 id="1-线性预热学习率"><a href="#1-线性预热学习率" class="headerlink" title="1. 线性预热学习率"></a>1. 线性预热学习率</h3><h4 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h4><p>线性预热学习率（Linear Learning Rate Warm-up）是一种在训练初期逐步增加学习率的策略。这种方法在大规模深度学习模型训练中变得越来越流行，尤其是在使用大批量（large batch）训练时。</p><h4 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h4><ol><li><p><strong>避免梯度爆炸</strong>：</p><ul><li>在训练的早期阶段，如果立即使用较大的学习率，模型参数可能会因为过大的梯度更新而导致梯度爆炸（gradient explosion），从而使模型训练失败。</li><li>通过线性预热，学习率从一个较小的值逐步增加到预设的较大值，这样可以使模型在初始阶段逐步适应梯度更新，避免剧烈的参数变化。</li></ul></li><li><p><strong>稳定训练过程</strong>：</p><ul><li>在模型训练的初期，权重初始化阶段参数通常比较随机，梯度也不稳定。较小的学习率有助于模型在早期阶段稳定下来，确保初始的训练过程更加平稳。</li><li>逐步增加学习率可以使模型在接下来的训练中更加稳定，提高训练的收敛性和效果。</li></ul></li></ol><h3 id="2-学习率衰减策略"><a href="#2-学习率衰减策略" class="headerlink" title="2. 学习率衰减策略"></a>2. 学习率衰减策略</h3><h4 id="背景：-1"><a href="#背景：-1" class="headerlink" title="背景："></a>背景：</h4><p>学习率衰减（Learning Rate Decay）是指在训练过程中逐步减小学习率的策略，目的是为了在训练后期更精细地调整模型参数，从而获得更好的泛化性能。</p><h4 id="原因：-1"><a href="#原因：-1" class="headerlink" title="原因："></a>原因：</h4><ol><li><p><strong>提高模型的泛化能力</strong>：</p><ul><li>在训练初期使用较大的学习率可以加速收敛，但在训练后期如果继续使用较大的学习率，会导致模型在局部最优解附近振荡，难以达到全局最优。</li><li>逐步减小学习率可以使模型在接近最优解时更精细地调整参数，减少在最优解附近的振荡，从而提高模型的泛化能力。</li></ul></li><li><p><strong>防止过拟合</strong>：</p><ul><li>在训练的后期，模型可能会逐渐开始过拟合训练数据。降低学习率可以减缓参数更新的速度，减少过拟合的风险。</li></ul></li></ol><h3 id="3-关闭拼接数据增强（Mosaic-Data-Augmentation）"><a href="#3-关闭拼接数据增强（Mosaic-Data-Augmentation）" class="headerlink" title="3. 关闭拼接数据增强（Mosaic Data Augmentation）"></a>3. 关闭拼接数据增强（Mosaic Data Augmentation）</h3><h4 id="背景：-2"><a href="#背景：-2" class="headerlink" title="背景："></a>背景：</h4><p>拼接数据增强是一种在YOLO系列模型中常用的数据增强技术，它通过将多张图片拼接成一张图片来增加数据的多样性，从而提高模型的鲁棒性。</p><h4 id="原因：-2"><a href="#原因：-2" class="headerlink" title="原因："></a>原因：</h4><ol><li><p><strong>减少训练数据的复杂性</strong>：</p><ul><li>在训练初期和中期，拼接数据增强通过增加训练数据的多样性，有助于模型学习到更加鲁棒的特征。</li><li>然而，在训练的后期，模型已经基本掌握了主要特征，此时继续使用复杂的拼接数据可能会引入不必要的噪音，影响模型对细节的学习。</li></ul></li><li><p><strong>精细调整模型参数</strong>：</p><ul><li>在最后的训练阶段，关闭拼接数据增强可以让模型专注于原始图片数据的特征学习和调整，进一步提高模型在真实数据上的性能。</li><li>这一步骤有助于模型在最后的几轮训练中进行精细调整，提升最终的检测准确性。</li></ul></li></ol><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>采用线性预热学习率、学习率衰减策略和在训练后期关闭拼接数据增强，都是为了确保模型在不同训练阶段的稳定性和高效性。这些策略的结合可以提高模型的收敛速度，增强模型的泛化能力，并最终提升模型在实际应用中的表现。</p><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="Adam优化器"><a href="#Adam优化器" class="headerlink" title="Adam优化器"></a>Adam优化器</h3><p><strong>Adam (Adaptive Moment Estimation) 优化器</strong> 是一种自适应学习率优化算法，它结合了RMSProp和动量（Momentum）的优点，通过计算梯度的一阶动量和二阶动量的指数加权平均来动态调整学习率。Adam优化器在训练过程中自适应调整每个参数的学习率，因此在处理稀疏梯度和非平稳目标时表现良好。</p><h4 id="主要特点和公式："><a href="#主要特点和公式：" class="headerlink" title="主要特点和公式："></a>主要特点和公式：</h4><ul><li><p><strong>动量（Momentum）：</strong></p><ul><li><script type="math/tex; mode=display">m_t = \beta_1 m_{t-1} + (1 - \beta_1) g_t</script></li><li>其中，$\beta_1 $ 是一阶动量的指数衰减率，通常设置为0.9。</li></ul></li><li><p><strong>均方根传播（RMSProp）：</strong></p><ul><li><script type="math/tex; mode=display">v_t = \beta_2 v_{t-1} + (1 - \beta_2) g_t^2</script></li><li>其中，$ \beta_2 $ 是二阶动量的指数衰减率，通常设置为0.999。</li></ul></li><li><p><strong>偏差修正：</strong></p><ul><li>为了抵消在初始阶段动量和均方根值的偏差，Adam对动量和均方根值进行修正：</li><li><script type="math/tex; mode=display">\hat{m}_t = \frac{m_t}{1 - \beta_1^t}</script></li><li><script type="math/tex; mode=display">\hat{v}_t = \frac{v_t}{1 - \beta_2^t}</script></li></ul></li><li><p><strong>参数更新：</strong></p><ul><li><script type="math/tex; mode=display">\theta_t = \theta_{t-1} - \alpha \frac{\hat{m}_t}{\sqrt{\hat{v}_t} + \epsilon}</script></li><li>其中$ \alpha $ 是学习率，$ \epsilon $ 是一个很小的数，防止除零错误。</li></ul></li></ul><h3 id="AdamW优化器"><a href="#AdamW优化器" class="headerlink" title="AdamW优化器"></a>AdamW优化器</h3><p><strong>AdamW优化器</strong> 是一种改进的Adam优化器，专门设计用于处理权重衰减（weight decay）。权重衰减是一种正则化技术，用于防止过拟合。传统的Adam优化器在应用权重衰减时存在一些问题，AdamW通过将权重衰减独立于梯度更新进行处理，改进了这一点。</p><h4 id="主要特点和区别："><a href="#主要特点和区别：" class="headerlink" title="主要特点和区别："></a>主要特点和区别：</h4><ul><li><strong>权重衰减：</strong><ul><li>在Adam中，权重衰减被错误地应用到了动量和自适应学习率调整中，导致其行为类似于L2正则化，而不是标准的权重衰减。</li><li>在AdamW中，权重衰减被直接应用于参数更新，而不影响动量和梯度的计算：</li><li>$ \theta<em>t = \theta</em>{t-1} - \alpha \left( \frac{\hat{m}<em>t}{\sqrt{\hat{v}_t} + \epsilon} + \lambda \theta</em>{t-1} \right) $</li><li>其中，$ \lambda $ 是权重衰减系数。</li></ul></li></ul><h3 id="余弦退火调度"><a href="#余弦退火调度" class="headerlink" title="余弦退火调度"></a>余弦退火调度</h3><p><strong>余弦退火调度（Cosine Annealing Scheduler）</strong> 是一种用于调整学习率的策略，主要应用于深度学习模型的训练过程中，以提高模型的收敛速度和性能。余弦退火调度通过余弦函数的周期性变化来动态调整学习率，使其在训练过程中逐步减小。</p><h4 id="主要特点和公式：-1"><a href="#主要特点和公式：-1" class="headerlink" title="主要特点和公式："></a>主要特点和公式：</h4><ul><li><p><strong>学习率的变化：</strong></p><ul><li>学习率按照余弦函数进行退火，公式如下：</li><li><script type="math/tex; mode=display">\eta_t = \eta_{\text{min}} + \frac{1}{2} (\eta_{\text{max}} - \eta_{\text{min}}) \left(1 + \cos\left(\frac{T_{\text{cur}}}{T} \pi\right)\right)</script></li><li>其中，$ \eta<em>t $ 是第t步的学习率，$ \eta</em>{\text{min}} $ 和 $ \eta<em>{\text{max}} $ 分别是最小和最大的学习率，$ T</em>{\text{cur}} $ 是当前的epoch，$ T $是总的退火周期。</li></ul></li><li><p><strong>学习率周期性重启：</strong></p><ul><li>在某些变体中，余弦退火调度还可以结合学习率重启（cosine annealing with warm restarts），在每个周期结束时将学习率重新设置为初始值，然后再次开始余弦退火。这样可以在训练过程中避免局部最优解，提高模型的最终性能。</li></ul></li></ul><h3 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h3><p>通过结合使用AdamW优化器和余弦退火调度，YOLOv9模型在训练过程中能够自适应调整学习率，有效防止梯度爆炸和梯度消失问题，同时通过正则化提高模型的泛化能力。这些技术的综合应用有助于提升模型的训练效率和最终性能。</p><p>在YOLOv9的训练过程中，使用了TaskAlign样本匹配、BCE Loss、DFL Loss和CIoU Loss来优化模型性能。下面是这些概念的详细解释及其背后的原因：</p><h3 id="TaskAlign样本匹配"><a href="#TaskAlign样本匹配" class="headerlink" title="TaskAlign样本匹配"></a>TaskAlign样本匹配</h3><p><strong>TaskAlign样本匹配</strong> 是一种改进的样本匹配策略，旨在更好地分配正样本和负样本。样本匹配是目标检测模型训练中的关键步骤，决定了哪些锚框（anchor boxes）被认为是正样本（包含目标）或者负样本（不包含目标）。</p><h4 id="主要特点和原因："><a href="#主要特点和原因：" class="headerlink" title="主要特点和原因："></a>主要特点和原因：</h4><ul><li><p><strong>动态样本分配：</strong></p><ul><li>TaskAlign通过动态调整正样本和负样本的分配，确保每个训练样本都有合理的匹配目标。这种动态分配能够自适应调整不同目标的比例，提升模型对各种目标的检测能力。</li></ul></li><li><p><strong>提高匹配质量：</strong></p><ul><li>传统的样本匹配方法可能会导致一些困难样本匹配不到正样本，从而影响模型的检测性能。TaskAlign通过优化样本分配，提高了匹配质量，进而提升了模型的训练效果。</li></ul></li></ul><h3 id="分类损失：BCE-Loss"><a href="#分类损失：BCE-Loss" class="headerlink" title="分类损失：BCE Loss"></a>分类损失：BCE Loss</h3><p><strong>二元交叉熵损失（Binary Cross-Entropy Loss, BCE Loss）</strong> 是一种常用的分类损失函数，用于衡量预测概率分布与真实标签之间的差异。</p><h4 id="公式："><a href="#公式：" class="headerlink" title="公式："></a>公式：</h4><script type="math/tex; mode=display">\text{BCE Loss} = - \frac{1}{N} \sum_{i=1}^{N} \left( y_i \log(p_i) + (1 - y_i) \log(1 - p_i) \right)</script><p>其中，$ y_i $ 是第 $ i $ 个样本的真实标签，$ p_i $ 是第 $ i $ 个样本的预测概率，$ N $ 是样本总数。</p><h4 id="原因：-3"><a href="#原因：-3" class="headerlink" title="原因："></a>原因：</h4><ul><li><p><strong>适用于二分类问题：</strong></p><ul><li>BCE Loss专为二分类问题设计，非常适合目标检测任务中的目标/背景分类。</li></ul></li><li><p><strong>平衡正负样本：</strong></p><ul><li>BCE Loss在正样本和负样本之间进行平衡，使模型能够更好地学习正负样本的区别。</li></ul></li></ul><h3 id="回归损失：DFL-Loss-CIoU-Loss"><a href="#回归损失：DFL-Loss-CIoU-Loss" class="headerlink" title="回归损失：DFL Loss + CIoU Loss"></a>回归损失：DFL Loss + CIoU Loss</h3><p>在目标检测任务中，回归损失用于优化边界框的预测，使其更加准确地定位目标。</p><h4 id="1-分布焦点损失（Distribution-Focal-Loss-DFL-Loss）"><a href="#1-分布焦点损失（Distribution-Focal-Loss-DFL-Loss）" class="headerlink" title="1. 分布焦点损失（Distribution Focal Loss, DFL Loss）"></a>1. 分布焦点损失（Distribution Focal Loss, DFL Loss）</h4><p><strong>DFL Loss</strong> 是一种专门用于边界框回归的损失函数，旨在优化预测的分布，使预测值更接近真实值。</p><h4 id="原因：-4"><a href="#原因：-4" class="headerlink" title="原因："></a>原因：</h4><ul><li><strong>增强预测精度：</strong><ul><li>DFL Loss通过优化预测值的分布，增强了模型对边界框位置的预测精度。</li></ul></li></ul><h4 id="2-完全交并比损失（Complete-Intersection-over-Union-Loss-CIoU-Loss）"><a href="#2-完全交并比损失（Complete-Intersection-over-Union-Loss-CIoU-Loss）" class="headerlink" title="2. 完全交并比损失（Complete Intersection over Union Loss, CIoU Loss）"></a>2. 完全交并比损失（Complete Intersection over Union Loss, CIoU Loss）</h4><p><strong>CIoU Loss</strong> 是一种改进的IoU损失函数，综合考虑了边界框的重叠面积、中心点距离和长宽比，从而更全面地衡量预测框与真实框的差异。</p><h4 id="公式：-1"><a href="#公式：-1" class="headerlink" title="公式："></a>公式：</h4><script type="math/tex; mode=display">\text{CIoU} = \text{IoU} - \frac{\rho^2(\mathbf{b}, \mathbf{b}^\text{gt})}{c^2} - \alpha \frac{v}{1 - \text{IoU} + v}</script><p>其中：</p><ul><li>$ \text{IoU} $ 是预测框与真实框的交并比。</li><li>$ \rho(\mathbf{b}, \mathbf{b}^\text{gt}) $ 是预测框中心与真实框中心的欧几里得距离。</li><li>$ c $ 是包围框对角线的长度。</li><li>$ v $ 是衡量预测框与真实框长宽比的一致性。</li><li>$ \alpha $ 是一个平衡参数。</li></ul><h4 id="原因：-5"><a href="#原因：-5" class="headerlink" title="原因："></a>原因：</h4><ul><li><p><strong>综合评估误差：</strong></p><ul><li>CIoU Loss不仅考虑边界框的重叠面积，还考虑中心点距离和长宽比，使其能够更全面地评估边界框的误差。</li></ul></li><li><p><strong>更快收敛：</strong></p><ul><li>CIoU Loss在优化过程中能够更快地收敛，提高训练效率。</li></ul></li></ul><h3 id="结论-2"><a href="#结论-2" class="headerlink" title="结论"></a>结论</h3><p>通过使用TaskAlign样本匹配、BCE Loss、DFL Loss和CIoU Loss，YOLOv9能够更好地分配正负样本，优化分类和边界框回归，使得模型在目标检测任务中表现出更高的精度和鲁棒性。这些优化策略的综合应用，确保了YOLOv9在训练过程中能够高效收敛，并在实际应用中具有较强的性能表现。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;深度学习项目流程&quot;&gt;&lt;a href=&quot;#深度学习项目流程&quot; class=&quot;headerlink&quot; title=&quot;深度学习项目流程&quot;&gt;&lt;/a&gt;深度学习项目流程&lt;/h2&gt;&lt;p&gt;完成一个深度学习项目通常包括以下几个步骤，每个步骤都需要仔细规划和执行：&lt;/p&gt;
&lt;h3 i</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>STFT</title>
    <link href="https://kryptonzy.github.io/blog/2024/06/12/STFT/"/>
    <id>https://kryptonzy.github.io/blog/2024/06/12/STFT/</id>
    <published>2024-06-12T03:15:51.027Z</published>
    <updated>2024-06-18T05:52:19.922Z</updated>
    
    <content type="html"><![CDATA[<h1 id="STFT介绍"><a href="#STFT介绍" class="headerlink" title="STFT介绍"></a>STFT介绍</h1><p>短时傅里叶变换（Short-Time Fourier Transform, STFT）是傅里叶变换的一种，它通过在时间轴上应用移动窗口来分析信号的频率内容随时间的变化。STFT 是时频分析的基本工具之一，特别适用于分析非平稳信号（即频率成分随时间变化的信号）。</p><h3 id="数学原理"><a href="#数学原理" class="headerlink" title="数学原理"></a>数学原理</h3><h4 id="连续时间信号的STFT"><a href="#连续时间信号的STFT" class="headerlink" title="连续时间信号的STFT"></a>连续时间信号的STFT</h4><p>设 $ x(t) $ 是一个连续时间信号，$ w(t) $ 是一个移动窗口函数（通常是一个短时窗，如汉宁窗或高斯窗）。STFT 的定义为：</p><script type="math/tex; mode=display">\text{STFT}_x(t, \omega) = \int_{-\infty}^{\infty} x(\tau) w(\tau - t) e^{-j \omega \tau} \, d\tau</script><p>其中：</p><ul><li>$ \text{STFT}_x(t, \omega)$是在时间 $ t $ 和频率 $ \omega $ 上的短时傅里叶变换。</li><li>$ x(\tau) $ 是原始信号。</li><li>$ w(\tau - t) $ 是移动窗口函数，中心位于 $ t $。</li><li>$ e^{-j \omega \tau} $ 是傅里叶变换的核函数。</li></ul><p>STFT 将信号在每个时间点 $ t $ 上截取一个窗函数 $ w(t) $，并对窗口内的信号进行傅里叶变换。通过移动窗函数的位置，可以得到不同时间点上的频谱，从而得到信号的时频表示。</p><h4 id="离散时间信号的STFT"><a href="#离散时间信号的STFT" class="headerlink" title="离散时间信号的STFT"></a>离散时间信号的STFT</h4><p>对于离散时间信号 $ x[n] $，其STFT定义为：</p><script type="math/tex; mode=display">\text{STFT}_x(m, \omega) = \sum_{n=-\infty}^{\infty} x[n] w[n - m] e^{-j \omega n}</script><p>其中：</p><ul><li>$ x[n] $ 是离散时间信号。</li><li>$ w[n - m] $ 是移动窗口函数，中心位于 $ m $。</li><li>$ e^{-j \omega n} $ 是傅里叶变换的核函数。</li></ul><p>通常，离散时间STFT的频率参数 $ \omega $ 被离散化为 $ \omega = \frac{2\pi k}{N} $（其中 $ N $ 是FFT的长度），因此离散STFT可以表示为：</p><script type="math/tex; mode=display">\text{STFT}_x(m, k) = \sum_{n=-\infty}^{\infty} x[n] w[n - m] e^{-j \frac{2\pi k}{N} n}</script><h3 id="STFT的步骤"><a href="#STFT的步骤" class="headerlink" title="STFT的步骤"></a>STFT的步骤</h3><ol><li><p><strong>窗口化</strong>：</p><ul><li>使用一个窗函数（如汉宁窗、高斯窗等）截取信号的一部分。窗口函数通常是一个短时窗，长度较短，可以移动。</li></ul></li><li><p><strong>移动窗口</strong>：</p><ul><li>将窗口函数在信号上移动，每次移动一个步长（通常称为 hop size），截取信号的不同部分。</li></ul></li><li><p><strong>傅里叶变换</strong>：</p><ul><li>对每个窗口内的信号进行傅里叶变换，计算出窗口内信号的频谱。</li></ul></li><li><p><strong>组合结果</strong>：</p><ul><li>将每个时间窗口的频谱组合在一起，形成信号的时频表示。</li></ul></li></ol><h3 id="STFT-的特性"><a href="#STFT-的特性" class="headerlink" title="STFT 的特性"></a>STFT 的特性</h3><ul><li><p><strong>时间和频率分辨率的权衡</strong>：</p><ul><li>窗口的长度决定了时间和频率分辨率之间的权衡。较短的窗口提供较高的时间分辨率，但频率分辨率较低；较长的窗口提供较高的频率分辨率，但时间分辨率较低。</li></ul></li><li><p><strong>非平稳信号的分析</strong>：</p><ul><li>STFT 特别适用于分析非平稳信号，可以捕捉信号频率成分随时间的变化。</li></ul></li></ul><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>以下是使用STFT进行时频分析的示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> scipy.signal <span class="keyword">import</span> stft</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成示例信号</span></span><br><span class="line">fs = <span class="number">1000</span>  <span class="comment"># 采样频率</span></span><br><span class="line">T = <span class="number">1</span>  <span class="comment"># 信号持续时间</span></span><br><span class="line">t = np.linspace(<span class="number">0</span>, T, fs * T, endpoint=<span class="literal">False</span>)  <span class="comment"># 时间向量</span></span><br><span class="line">signal = np.sin(<span class="number">2</span> * np.pi * <span class="number">50</span> * t) + <span class="number">0.5</span> * np.sin(<span class="number">2</span> * np.pi * <span class="number">120</span> * t)  <span class="comment"># 示例信号</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算STFT</span></span><br><span class="line">f, t, Zxx = stft(signal, fs, nperseg=<span class="number">256</span>, noverlap=<span class="number">128</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制STFT结果</span></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">6</span>))</span><br><span class="line">plt.pcolormesh(t, f, np.<span class="built_in">abs</span>(Zxx), shading=<span class="string">&#x27;gouraud&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Frequency [Hz]&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Time [sec]&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;STFT Magnitude&#x27;</span>)</span><br><span class="line">plt.colorbar(label=<span class="string">&#x27;Magnitude&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h4 id="nperseg、noverlap和-nfft参数的选择"><a href="#nperseg、noverlap和-nfft参数的选择" class="headerlink" title="nperseg、noverlap和 nfft参数的选择"></a><code>nperseg</code>、<code>noverlap</code>和 <code>nfft</code>参数的选择</h4><p>对于长度为512的EEG信号，选择 <code>nperseg</code>、<code>noverlap</code>和 <code>nfft</code>参数时需要考虑时间和频率分辨率之间的权衡。以下是一些选择这些参数的原则和示例：</p><ol><li><p><strong><code>nperseg</code> (每段的长度)</strong>:</p><ul><li>该参数决定了每个段的长度。通常，<code>nperseg</code>的选择应该小于信号长度，以便可以进行多段分析。</li><li>较小的 <code>nperseg</code>会提高时间分辨率，但会降低频率分辨率。反之，较大的 <code>nperseg</code>会提高频率分辨率，但会降低时间分辨率。</li></ul></li><li><p><strong><code>noverlap</code> (每段重叠的点数)</strong>:</p><ul><li>该参数决定了相邻段之间的重叠点数。通常设置为 <code>nperseg</code>的一半，以实现平滑的频谱估计。</li><li>较高的重叠率（即 <code>noverlap</code>较大）会增加计算量，但可以获得更平滑的频谱图。</li></ul></li><li><p><strong><code>nfft</code> (每段的FFT点数)</strong>:</p><ul><li>该参数决定了FFT的点数，通常设置为大于或等于 <code>nperseg</code>的值。</li><li>较大的 <code>nfft</code>会增加频率分辨率，但也会增加计算量。</li></ul></li></ol><p>对于长度为512的EEG信号，以下是一个推荐的参数选择：</p><ul><li><code>nperseg = 128</code>: 这是一个常用的值，提供了适中的时间和频率分辨率。</li><li><code>noverlap = 64</code>: 这是 <code>nperseg</code>的一半，提供了平滑的频谱估计。</li><li><code>nfft = 256</code>: 这是 <code>nperseg</code>的两倍，提供了较高的频率分辨率。</li></ul><p>以下是示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> scipy.signal <span class="keyword">import</span> spectrogram</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成示例EEG信号</span></span><br><span class="line">fs = <span class="number">256</span>  <span class="comment"># 采样率</span></span><br><span class="line">signal_length = <span class="number">512</span></span><br><span class="line">t = np.linspace(<span class="number">0</span>, signal_length / fs, signal_length, endpoint=<span class="literal">False</span>)  <span class="comment"># 时间向量</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成一个包含正弦波和噪声的示例信号</span></span><br><span class="line">f0 = <span class="number">10</span>  <span class="comment"># 信号频率</span></span><br><span class="line">signal = np.sin(<span class="number">2</span> * np.pi * f0 * t) + <span class="number">0.5</span> * np.random.randn(<span class="built_in">len</span>(t))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置参数</span></span><br><span class="line">nperseg = <span class="number">128</span></span><br><span class="line">noverlap = <span class="number">64</span></span><br><span class="line">nfft = <span class="number">256</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算瞬时频率</span></span><br><span class="line">frequencies, times, Sxx = spectrogram(signal, fs, nperseg=nperseg, noverlap=noverlap, nfft=nfft)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制时频图</span></span><br><span class="line">plt.pcolormesh(times, frequencies, <span class="number">10</span> * np.log10(Sxx), shading=<span class="string">&#x27;gouraud&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Frequency [Hz]&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Time [sec]&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Spectrogram&#x27;</span>)</span><br><span class="line">plt.colorbar(label=<span class="string">&#x27;Intensity [dB]&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h3 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h3><ol><li><p><strong>生成示例EEG信号</strong>:</p><ul><li><code>fs</code> 是采样率，<code>signal_length</code> 是信号长度，<code>t</code> 是时间向量。</li><li>生成一个包含频率为 <code>f0</code>的正弦波和一些随机噪声的信号。</li></ul></li><li><p><strong>设置参数</strong>:</p><ul><li><code>nperseg = 128</code>: 每段长度为128。</li><li><code>noverlap = 64</code>: 每段之间有64个点的重叠。</li><li><code>nfft = 256</code>: 每段进行256点的FFT计算。</li></ul></li><li><p><strong>计算瞬时频率</strong>:</p><ul><li>使用 <code>scipy.signal.spectrogram</code> 函数计算瞬时频率。</li></ul></li><li><p><strong>绘制时频图</strong>:</p><ul><li>使用 <code>matplotlib</code> 绘制时频图。</li></ul></li></ol><p>通过这些参数设置，您可以获得一个平衡的时间和频率分辨率，适合分析长度为512的EEG信号。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>STFT 是一种通过在时间轴上应用移动窗口来分析信号频率内容随时间变化的方法。通过选择不同的窗口长度和步长，可以在时间和频率分辨率之间进行权衡，适用于分析非平稳信号。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;STFT介绍&quot;&gt;&lt;a href=&quot;#STFT介绍&quot; class=&quot;headerlink&quot; title=&quot;STFT介绍&quot;&gt;&lt;/a&gt;STFT介绍&lt;/h1&gt;&lt;p&gt;短时傅里叶变换（Short-Time Fourier Transform, STFT）是傅里叶变换的一种，它</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>瞬时频率</title>
    <link href="https://kryptonzy.github.io/blog/2024/06/12/%E7%9E%AC%E6%97%B6%E9%A2%91%E7%8E%87/"/>
    <id>https://kryptonzy.github.io/blog/2024/06/12/%E7%9E%AC%E6%97%B6%E9%A2%91%E7%8E%87/</id>
    <published>2024-06-11T16:37:38.887Z</published>
    <updated>2024-06-12T05:59:41.108Z</updated>
    
    <content type="html"><![CDATA[<h1 id="两种计算瞬时频率的方法"><a href="#两种计算瞬时频率的方法" class="headerlink" title="两种计算瞬时频率的方法"></a>两种计算瞬时频率的方法</h1><p>这两种方法在计算瞬时频率时有不同的原理和应用场景：</p><h3 id="Hilbert-变换方法"><a href="#Hilbert-变换方法" class="headerlink" title="Hilbert 变换方法"></a>Hilbert 变换方法</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>Hilbert 变换方法通过计算信号的解析信号（analytic signal），并从中获取相位信息。然后，通过对相位进行微分得到瞬时频率。其数学表达式为：</p><script type="math/tex; mode=display">f_{\text{inst}}(t) = \frac{1}{2\pi} \frac{d\phi}{dt}</script><p>其中，$\phi$ 是解析信号的相位。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol><li><p><strong>优点</strong>：</p><ul><li>直接且快速，适用于单分量信号（即信号的频率在任一时刻是单一的）。</li><li>对于噪声相对不敏感。</li></ul></li><li><p><strong>缺点</strong>：</p><ul><li>对于多分量信号（即信号在同一时刻含有多个频率成分）效果较差，因为无法区分不同的频率成分。</li><li>对非平稳信号的瞬时频率变化可能不够准确。</li></ul></li></ol><h3 id="条件频谱矩方法（TFMoment）"><a href="#条件频谱矩方法（TFMoment）" class="headerlink" title="条件频谱矩方法（TFMoment）"></a>条件频谱矩方法（TFMoment）</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>条件频谱矩方法基于时间-频率分布（如谱图）的功率谱来计算瞬时频率。它计算在每个时刻的频谱重心，公式如下：</p><script type="math/tex; mode=display">f_{\text{inst}}(t) = \frac{\int_0^\infty f P(t, f) \, df}{\int_0^\infty P(t, f) \, df}</script><p>其中，$P(t, f)$ 是时间 $t$ 和频率 $f$ 下的功率谱。</p><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ol><li><p><strong>优点</strong>：</p><ul><li>适用于多分量信号，能够区分和处理多个频率成分。</li><li>能够更准确地捕捉非平稳信号的瞬时频率变化。</li></ul></li><li><p><strong>缺点</strong>：</p><ul><li>计算复杂度较高，需要计算时间-频率分布（如谱图）。</li><li>对于噪声敏感，可能需要对信号进行预处理以减少噪声的影响。</li></ul></li></ol><h3 id="如何选择方法"><a href="#如何选择方法" class="headerlink" title="如何选择方法"></a>如何选择方法</h3><ul><li><strong>单分量信号</strong>：如果您的信号在任一时刻只包含一个主要频率成分，并且信号相对平稳，Hilbert 变换方法可能更简单高效。</li><li><strong>多分量信号或非平稳信号</strong>：如果您的信号包含多个频率成分或是非平稳信号，条件频谱矩方法（TFMoment）更适合，因为它能够更准确地捕捉复杂信号的频率变化。</li></ul><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>这里是两个方法的实现示例，您可以根据您的具体需求选择合适的方法。</p><h4 id="Hilbert-变换方法-1"><a href="#Hilbert-变换方法-1" class="headerlink" title="Hilbert 变换方法"></a>Hilbert 变换方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> scipy.signal <span class="keyword">import</span> hilbert</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compute_instantaneous_frequency_hilbert</span>(<span class="params">signal, fs</span>):</span><br><span class="line">    n_channels, n_samples = signal.shape</span><br><span class="line">    inst_freq = []</span><br><span class="line">    t = np.arange(n_samples - <span class="number">1</span>) / fs</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> channel <span class="keyword">in</span> <span class="built_in">range</span>(n_channels):</span><br><span class="line">        analytic_signal = hilbert(signal[channel])</span><br><span class="line">        instantaneous_phase = np.unwrap(np.angle(analytic_signal))</span><br><span class="line">        instantaneous_frequency = np.diff(instantaneous_phase) * fs / (<span class="number">2.0</span> * np.pi)</span><br><span class="line">        inst_freq.append(instantaneous_frequency)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> np.array(inst_freq), t</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例信号</span></span><br><span class="line">fs = <span class="number">1000</span></span><br><span class="line">T = <span class="number">1</span></span><br><span class="line">t = np.linspace(<span class="number">0</span>, T, fs * T, endpoint=<span class="literal">False</span>)</span><br><span class="line">signal = np.sin(<span class="number">2</span> * np.pi * <span class="number">50</span> * t) + <span class="number">0.5</span> * np.sin(<span class="number">2</span> * np.pi * <span class="number">120</span> * t)</span><br><span class="line"></span><br><span class="line">x = np.expand_dims(signal, axis=<span class="number">0</span>)</span><br><span class="line">instantaneous_frequency, time_points = compute_instantaneous_frequency_hilbert(x, fs)</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">12</span>, <span class="number">6</span>))</span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">plt.plot(t, signal)</span><br><span class="line">plt.title(<span class="string">&#x27;Input Signal&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Time [s]&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Amplitude&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">plt.plot(time_points, instantaneous_frequency[<span class="number">0</span>, :])</span><br><span class="line">plt.title(<span class="string">&#x27;Instantaneous Frequency (Hilbert)&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Time [s]&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Frequency [Hz]&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h4 id="条件频谱矩方法（TFMoment）-1"><a href="#条件频谱矩方法（TFMoment）-1" class="headerlink" title="条件频谱矩方法（TFMoment）"></a>条件频谱矩方法（TFMoment）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> scipy.signal <span class="keyword">import</span> spectrogram</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compute_instantaneous_frequency_tfmoment</span>(<span class="params">signal, fs, nperseg=<span class="number">256</span>, noverlap=<span class="number">128</span>, nfft=<span class="number">256</span></span>):</span><br><span class="line">    n_channels, n_samples = signal.shape</span><br><span class="line">    inst_freq = []</span><br><span class="line">    t_vals = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> channel <span class="keyword">in</span> <span class="built_in">range</span>(n_channels):</span><br><span class="line">        f, t, Sxx = spectrogram(signal[channel], fs, nperseg=nperseg, noverlap=noverlap, nfft=nfft)</span><br><span class="line">        P_t_f = Sxx.T</span><br><span class="line">        numerator = np.<span class="built_in">sum</span>(f * P_t_f, axis=<span class="number">1</span>)</span><br><span class="line">        denominator = np.<span class="built_in">sum</span>(P_t_f, axis=<span class="number">1</span>)</span><br><span class="line">        inst_freq_channel = numerator / denominator</span><br><span class="line">        inst_freq.append(inst_freq_channel)</span><br><span class="line">        t_vals.append(t)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> np.array(inst_freq), np.array(t_vals[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例信号</span></span><br><span class="line">fs = <span class="number">1000</span></span><br><span class="line">T = <span class="number">1</span></span><br><span class="line">t = np.linspace(<span class="number">0</span>, T, fs * T, endpoint=<span class="literal">False</span>)</span><br><span class="line">signal = np.sin(<span class="number">2</span> * np.pi * <span class="number">50</span> * t) + <span class="number">0.5</span> * np.sin(<span class="number">2</span> * np.pi * <span class="number">120</span> * t)</span><br><span class="line"></span><br><span class="line">x = np.expand_dims(signal, axis=<span class="number">0</span>)</span><br><span class="line">nperseg = <span class="number">128</span></span><br><span class="line">noverlap = <span class="number">64</span></span><br><span class="line">nfft = <span class="number">256</span></span><br><span class="line"></span><br><span class="line">instantaneous_frequency, time_points = compute_instantaneous_frequency_tfmoment(x, fs, nperseg, noverlap, nfft)</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">12</span>, <span class="number">6</span>))</span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">plt.plot(t, signal)</span><br><span class="line">plt.title(<span class="string">&#x27;Input Signal&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Time [s]&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Amplitude&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">plt.plot(time_points, instantaneous_frequency[<span class="number">0</span>, :])</span><br><span class="line">plt.title(<span class="string">&#x27;Instantaneous Frequency (TFMoment)&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Time [s]&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Frequency [Hz]&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>通过运行这些代码示例，您可以直观地看到不同方法的计算结果，并选择最适合您的应用场景的方法。如果您有进一步的需求或问题，请告诉我！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;两种计算瞬时频率的方法&quot;&gt;&lt;a href=&quot;#两种计算瞬时频率的方法&quot; class=&quot;headerlink&quot; title=&quot;两种计算瞬时频率的方法&quot;&gt;&lt;/a&gt;两种计算瞬时频率的方法&lt;/h1&gt;&lt;p&gt;这两种方法在计算瞬时频率时有不同的原理和应用场景：&lt;/p&gt;
&lt;h3 </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>世界是连续的还是离散的</title>
    <link href="https://kryptonzy.github.io/blog/2024/06/11/%E7%A6%BB%E6%95%A3%E8%BF%98%E6%98%AF%E8%BF%9E%E7%BB%AD/"/>
    <id>https://kryptonzy.github.io/blog/2024/06/11/%E7%A6%BB%E6%95%A3%E8%BF%98%E6%98%AF%E8%BF%9E%E7%BB%AD/</id>
    <published>2024-06-11T10:31:53.169Z</published>
    <updated>2024-06-12T06:00:13.786Z</updated>
    
    <content type="html"><![CDATA[<h1 id="世界是连续的还是离散的"><a href="#世界是连续的还是离散的" class="headerlink" title="世界是连续的还是离散的"></a>世界是连续的还是离散的</h1><p>“世界是连续的还是离散的”这一问题可以从不同的学科视角进行讨论，如物理学、哲学和计算机科学。每个领域的观点都可能有所不同。</p><h3 id="物理学视角"><a href="#物理学视角" class="headerlink" title="物理学视角"></a>物理学视角</h3><ol><li><strong>经典物理学</strong> ：</li></ol><ul><li>经典物理学（如牛顿力学、电磁学等）通常认为世界是连续的。例如，时间和空间被认为是连续的，物体可以在任何时间点和空间位置上运动。</li></ul><ol><li><strong>量子力学</strong> ：</li></ol><ul><li>量子力学提供了一种截然不同的观点。在微观尺度下，某些物理量是量子化的，即只能取离散的值。例如，电子的能级、光子的能量等都是离散的。这表明，在某些情况下，世界是离散的。</li><li>但量子力学中的波函数是连续的，它描述了粒子在空间中的概率分布。因此，量子力学同时包含连续和离散的特性。</li></ul><ol><li><strong>时空量子化</strong> ：</li></ol><ul><li>有些理论物理学家提出了时空量子化的概念，认为在极小尺度（如普朗克尺度）上，时空可能是离散的。这是一种仍在研究中的假设，尚未得到实验验证。</li></ul><h3 id="哲学视角"><a href="#哲学视角" class="headerlink" title="哲学视角"></a>哲学视角</h3><ol><li><strong>实在论</strong> ：</li></ol><ul><li>认为世界的本质是独立于我们的感知和测量的。对于这种观点，世界可以是连续的，也可以是离散的，这取决于其真实的物理特性。</li></ul><ol><li><strong>唯物主义</strong> ：</li></ol><ul><li>认为物质是世界的基本组成部分。这种观点通常倾向于认为世界是连续的，因为物质和能量的流动似乎是连续的。</li></ul><ol><li><strong>主观唯心主义</strong> ：</li></ol><ul><li>认为我们的感知决定了我们对世界的理解。对于这种观点，世界的连续性或离散性是由我们的感知和测量决定的，而不是世界本身的特性。</li></ul><h3 id="计算机科学视角"><a href="#计算机科学视角" class="headerlink" title="计算机科学视角"></a>计算机科学视角</h3><ol><li><strong>数字化世界</strong> ：</li></ol><ul><li>在计算机科学中，所有信息都是离散的。计算机处理离散的二进制数据，任何连续信号（如声音、图像）都必须经过采样和量化才能被计算机处理。</li></ul><ol><li><strong>模拟信号处理</strong> ：</li></ol><ul><li>虽然计算机处理的是离散信号，但它们可以模拟连续信号。这种模拟是通过高频采样和精确的计算来实现的。</li></ul><h3 id="综合视角"><a href="#综合视角" class="headerlink" title="综合视角"></a>综合视角</h3><ol><li><strong>多尺度视角</strong> ：</li></ol><ul><li>世界的连续性和离散性可能取决于观察的尺度。在宏观尺度上（如日常生活中的物体运动），世界看起来是连续的；而在微观尺度上（如原子和电子的行为），世界表现出离散性。</li></ul><ol><li><strong>测量和工具的限制</strong> ：</li></ol><ul><li>我们对世界的理解受到测量工具和方法的限制。高精度的测量工具可以揭示更微观的细节，而这些细节可能表现出离散性。</li></ul><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>世界是连续的还是离散的，取决于我们观察的尺度和视角。从宏观来看，世界似乎是连续的；从微观和量子力学的角度来看，世界表现出离散性。哲学上，世界的本质可能既包含连续性也包含离散性。这一问题并没有一个简单的答案，而是取决于具体的上下文和研究领域。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;世界是连续的还是离散的&quot;&gt;&lt;a href=&quot;#世界是连续的还是离散的&quot; class=&quot;headerlink&quot; title=&quot;世界是连续的还是离散的&quot;&gt;&lt;/a&gt;世界是连续的还是离散的&lt;/h1&gt;&lt;p&gt;“世界是连续的还是离散的”这一问题可以从不同的学科视角进行讨论，如物</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>谱熵</title>
    <link href="https://kryptonzy.github.io/blog/2024/06/11/%E8%B0%B1%E7%86%B5/"/>
    <id>https://kryptonzy.github.io/blog/2024/06/11/%E8%B0%B1%E7%86%B5/</id>
    <published>2024-06-11T09:23:23.869Z</published>
    <updated>2024-06-18T08:07:47.688Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Q1"><a href="#Q1" class="headerlink" title="Q1"></a>Q1</h2><p>计算功率谱密度（Power Spectral Density, PSD）的常见算法有以下几种，每种算法的计算结果略有不同，适用于不同的场景。下面介绍几种常见的计算 PSD 的算法，并解释它们的输出形状。</p><h3 id="1-快速傅里叶变换-FFT"><a href="#1-快速傅里叶变换-FFT" class="headerlink" title="1. 快速傅里叶变换 (FFT)"></a>1. 快速傅里叶变换 (FFT)</h3><p>FFT 是最常用的一种方法，适用于分析信号的整体频率特性。计算结果为一维频谱。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.fft <span class="keyword">import</span> fft, fftfreq</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calculate_psd_fft</span>(<span class="params">signal, fs</span>):</span><br><span class="line">    N = <span class="built_in">len</span>(signal)</span><br><span class="line">    fft_values = fft(signal)</span><br><span class="line">    psd = np.<span class="built_in">abs</span>(fft_values) ** <span class="number">2</span> / N</span><br><span class="line">    freqs = fftfreq(N, <span class="number">1</span>/fs)</span><br><span class="line">    <span class="keyword">return</span> freqs[:N//<span class="number">2</span>], psd[:N//<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">fs = <span class="number">1000</span></span><br><span class="line">T = <span class="number">1</span></span><br><span class="line">t = np.linspace(<span class="number">0</span>, T, fs * T, endpoint=<span class="literal">False</span>)</span><br><span class="line">signal = np.sin(<span class="number">2</span> * np.pi * <span class="number">50</span> * t) + <span class="number">0.5</span> * np.sin(<span class="number">2</span> * np.pi * <span class="number">120</span> * t)</span><br><span class="line"></span><br><span class="line">freqs_fft, psd_fft = calculate_psd_fft(signal, fs)</span><br><span class="line"><span class="built_in">print</span>(freqs_fft.shape, psd_fft.shape)  <span class="comment"># (500,) (500,)</span></span><br></pre></td></tr></table></figure><h3 id="2-短时傅里叶变换-STFT"><a href="#2-短时傅里叶变换-STFT" class="headerlink" title="2. 短时傅里叶变换 (STFT)"></a>2. 短时傅里叶变换 (STFT)</h3><p>STFT 适用于分析信号的时频特性。计算结果为二维时频图。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> scipy.signal <span class="keyword">import</span> stft</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calculate_psd_stft</span>(<span class="params">signal, fs, nperseg</span>):</span><br><span class="line">    f, t, Zxx = stft(signal, fs=fs, nperseg=nperseg)</span><br><span class="line">    psd = np.<span class="built_in">abs</span>(Zxx) ** <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> f, t, psd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">nperseg = <span class="number">256</span></span><br><span class="line">freqs_stft, times_stft, psd_stft = calculate_psd_stft(signal, fs, nperseg)</span><br><span class="line"><span class="built_in">print</span>(freqs_stft.shape, times_stft.shape, psd_stft.shape)  <span class="comment"># (129,) (8,) (129, 8)</span></span><br></pre></td></tr></table></figure><h3 id="3-韦尔奇方法-Welch’s-Method"><a href="#3-韦尔奇方法-Welch’s-Method" class="headerlink" title="3. 韦尔奇方法 (Welch’s Method)"></a>3. 韦尔奇方法 (Welch’s Method)</h3><p>Welch 方法通过将信号分段并计算每段的 PSD 来提高估计的稳定性。结果为一维频谱，平滑了频谱估计。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.signal <span class="keyword">import</span> welch</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calculate_psd_welch</span>(<span class="params">signal, fs, nperseg</span>):</span><br><span class="line">    freqs, psd = welch(signal, fs=fs, nperseg=nperseg)</span><br><span class="line">    <span class="keyword">return</span> freqs, psd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">freqs_welch, psd_welch = calculate_psd_welch(signal, fs, nperseg)</span><br><span class="line"><span class="built_in">print</span>(freqs_welch.shape, psd_welch.shape)  <span class="comment"># (129,) (129,)</span></span><br></pre></td></tr></table></figure><h3 id="4-自回归方法-AR-Method"><a href="#4-自回归方法-AR-Method" class="headerlink" title="4. 自回归方法 (AR Method)"></a>4. 自回归方法 (AR Method)</h3><p>自回归方法使用统计模型来估计信号的功率谱密度。结果为一维频谱，适用于平稳信号。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> spectrum <span class="keyword">import</span> aryule, pburg</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calculate_psd_ar</span>(<span class="params">signal, order, fs, method=<span class="string">&#x27;yule&#x27;</span></span>):</span><br><span class="line">    <span class="keyword">if</span> method == <span class="string">&#x27;yule&#x27;</span>:</span><br><span class="line">        ar, variance, _ = aryule(signal, order)</span><br><span class="line">        freqs, psd = pburg(signal, order, NFFT=<span class="built_in">len</span>(signal), sampling=fs)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;Unsupported method&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> freqs, psd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">order = <span class="number">15</span></span><br><span class="line">freqs_ar, psd_ar = calculate_psd_ar(signal, order, fs)</span><br><span class="line"><span class="built_in">print</span>(freqs_ar.shape, psd_ar.shape)  <span class="comment"># (1000,) (1000,)</span></span><br></pre></td></tr></table></figure><h3 id="结果总结"><a href="#结果总结" class="headerlink" title="结果总结"></a>结果总结</h3><ul><li><strong>FFT</strong>: 输出为一维数组，形状为 (N/2, )，表示频率和对应的 PSD。</li><li><strong>STFT</strong>: 输出为二维数组，形状为 (F, T)，表示频率和时间上的 PSD。</li><li><strong>Welch</strong>: 输出为一维数组，形状为 (N/2, )，表示频率和对应的 PSD。</li><li><strong>AR</strong>: 输出为一维数组，形状为 (N, )，表示频率和对应的 PSD。</li></ul><h3 id="示例代码完整性"><a href="#示例代码完整性" class="headerlink" title="示例代码完整性"></a>示例代码完整性</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># FFT</span></span><br><span class="line">freqs_fft, psd_fft = calculate_psd_fft(signal, fs)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;FFT:&quot;</span>, freqs_fft.shape, psd_fft.shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># STFT</span></span><br><span class="line">freqs_stft, times_stft, psd_stft = calculate_psd_stft(signal, fs, nperseg)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;STFT:&quot;</span>, freqs_stft.shape, times_stft.shape, psd_stft.shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Welch</span></span><br><span class="line">freqs_welch, psd_welch = calculate_psd_welch(signal, fs, nperseg)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Welch:&quot;</span>, freqs_welch.shape, psd_welch.shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># AR</span></span><br><span class="line">freqs_ar, psd_ar = calculate_psd_ar(signal, order, fs)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;AR:&quot;</span>, freqs_ar.shape, psd_ar.shape)</span><br></pre></td></tr></table></figure><p>每种方法都有其特定的应用场景和优缺点，选择合适的方法取决于具体的信号特性和分析需求。</p><h2 id="Q2"><a href="#Q2" class="headerlink" title="Q2"></a>Q2</h2><p>除了短时傅里叶变换 (STFT) 以外，还有几种方法可以用来分析信号在频率和时间上的功率谱密度 (PSD)。以下是几种常见的方法：</p><h3 id="1-小波变换-Wavelet-Transform"><a href="#1-小波变换-Wavelet-Transform" class="headerlink" title="1. 小波变换 (Wavelet Transform)"></a>1. 小波变换 (Wavelet Transform)</h3><p>小波变换是另一种时频分析方法，适用于分析非平稳信号。它通过使用不同尺度的小波函数对信号进行分解，从而得到信号在不同时间和频率上的局部特性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pywt</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calculate_psd_wavelet</span>(<span class="params">signal, fs, wavelet=<span class="string">&#x27;cmor&#x27;</span></span>):</span><br><span class="line">    scales = np.arange(<span class="number">1</span>, <span class="number">128</span>)</span><br><span class="line">    coefficients, frequencies = pywt.cwt(signal, scales, wavelet, sampling_period=<span class="number">1</span>/fs)</span><br><span class="line">    power_spectrum = (np.<span class="built_in">abs</span>(coefficients) ** <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> frequencies, power_spectrum</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">fs = <span class="number">1000</span>  <span class="comment"># 采样频率</span></span><br><span class="line">T = <span class="number">1</span>  <span class="comment"># 信号持续时间</span></span><br><span class="line">t = np.linspace(<span class="number">0</span>, T, fs * T, endpoint=<span class="literal">False</span>)</span><br><span class="line">signal = np.sin(<span class="number">2</span> * np.pi * <span class="number">50</span> * t) + <span class="number">0.5</span> * np.sin(<span class="number">2</span> * np.pi * <span class="number">120</span> * t)  <span class="comment"># 生成一个示例信号</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算功率谱</span></span><br><span class="line">frequencies_wavelet, power_spectrum_wavelet = calculate_psd_wavelet(signal, fs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制功率谱</span></span><br><span class="line">plt.imshow(power_spectrum_wavelet, extent=[<span class="number">0</span>, T, frequencies_wavelet[-<span class="number">1</span>], frequencies_wavelet[<span class="number">0</span>]], aspect=<span class="string">&#x27;auto&#x27;</span>, cmap=<span class="string">&#x27;jet&#x27;</span>)</span><br><span class="line">plt.colorbar(label=<span class="string">&#x27;Power&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Frequency [Hz]&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Time [sec]&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Power Spectrum Density (Wavelet Transform)&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h3 id="2-希尔伯特黄变换-Hilbert-Huang-Transform-HHT"><a href="#2-希尔伯特黄变换-Hilbert-Huang-Transform-HHT" class="headerlink" title="2. 希尔伯特黄变换 (Hilbert-Huang Transform, HHT)"></a>2. 希尔伯特黄变换 (Hilbert-Huang Transform, HHT)</h3><p>希尔伯特黄变换适用于处理非线性和非平稳信号。它主要由经验模态分解 (EMD) 和希尔伯特谱分析组成。EMD 将信号分解为若干本征模态函数 (IMFs)，然后对每个 IMF 进行希尔伯特变换得到瞬时频率。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> PyEMD <span class="keyword">import</span> EMD</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calculate_psd_hht</span>(<span class="params">signal, fs</span>):</span><br><span class="line">    emd = EMD()</span><br><span class="line">    imfs = emd(signal)</span><br><span class="line">    t = np.arange(<span class="built_in">len</span>(signal)) / fs</span><br><span class="line">    power_spectrum = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> imf <span class="keyword">in</span> imfs:</span><br><span class="line">        analytic_signal = hilbert(imf)</span><br><span class="line">        amplitude_envelope = np.<span class="built_in">abs</span>(analytic_signal)</span><br><span class="line">        instantaneous_frequency = np.unwrap(np.angle(analytic_signal)) / (<span class="number">2.0</span> * np.pi)</span><br><span class="line">        power_spectrum.append(amplitude_envelope ** <span class="number">2</span>)</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> t, instantaneous_frequency, power_spectrum</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">fs = <span class="number">1000</span>  <span class="comment"># 采样频率</span></span><br><span class="line">T = <span class="number">1</span>  <span class="comment"># 信号持续时间</span></span><br><span class="line">t = np.linspace(<span class="number">0</span>, T, fs * T, endpoint=<span class="literal">False</span>)</span><br><span class="line">signal = np.sin(<span class="number">2</span> * np.pi * <span class="number">50</span> * t) + <span class="number">0.5</span> * np.sin(<span class="number">2</span> * np.pi * <span class="number">120</span> * t)  <span class="comment"># 生成一个示例信号</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算功率谱</span></span><br><span class="line">times_hht, frequencies_hht, power_spectrum_hht = calculate_psd_hht(signal, fs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制功率谱</span></span><br><span class="line">plt.pcolormesh(times_hht, frequencies_hht, np.array(power_spectrum_hht).T, shading=<span class="string">&#x27;gouraud&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Frequency [Hz]&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Time [sec]&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Power Spectrum Density (Hilbert-Huang Transform)&#x27;</span>)</span><br><span class="line">plt.colorbar(label=<span class="string">&#x27;Power&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h3 id="3-Wigner-Ville-分布-Wigner-Ville-Distribution-WVD"><a href="#3-Wigner-Ville-分布-Wigner-Ville-Distribution-WVD" class="headerlink" title="3. Wigner-Ville 分布 (Wigner-Ville Distribution, WVD)"></a>3. Wigner-Ville 分布 (Wigner-Ville Distribution, WVD)</h3><p>Wigner-Ville 分布是一种用于信号时频分析的工具，适用于线性和非线性信号。它提供了高时间和频率分辨率，但可能会受到交叉项干扰的影响。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> tftb.processing <span class="keyword">import</span> WignerVilleDistribution</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calculate_psd_wvd</span>(<span class="params">signal, fs</span>):</span><br><span class="line">    t = np.arange(<span class="built_in">len</span>(signal)) / fs</span><br><span class="line">    wvd = WignerVilleDistribution(signal)</span><br><span class="line">    tfr, times, frequencies = wvd.run()</span><br><span class="line">    power_spectrum = np.<span class="built_in">abs</span>(tfr)</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> times, frequencies, power_spectrum</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">fs = <span class="number">1000</span>  <span class="comment"># 采样频率</span></span><br><span class="line">T = <span class="number">1</span>  <span class="comment"># 信号持续时间</span></span><br><span class="line">t = np.linspace(<span class="number">0</span>, T, fs * T, endpoint=<span class="literal">False</span>)</span><br><span class="line">signal = np.sin(<span class="number">2</span> * np.pi * <span class="number">50</span> * t) + <span class="number">0.5</span> * np.sin(<span class="number">2</span> * np.pi * <span class="number">120</span> * t)  <span class="comment"># 生成一个示例信号</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算功率谱</span></span><br><span class="line">times_wvd, frequencies_wvd, power_spectrum_wvd = calculate_psd_wvd(signal, fs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制功率谱</span></span><br><span class="line">plt.pcolormesh(times_wvd, frequencies_wvd, power_spectrum_wvd, shading=<span class="string">&#x27;gouraud&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Frequency [Hz]&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Time [sec]&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Power Spectrum Density (Wigner-Ville Distribution)&#x27;</span>)</span><br><span class="line">plt.colorbar(label=<span class="string">&#x27;Power&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>小波变换 (Wavelet Transform)</strong>: 提供信号在时间和频率上的局部特性，适用于非平稳信号。</li><li><strong>希尔伯特黄变换 (Hilbert-Huang Transform)</strong>: 适用于非线性和非平稳信号，通过 EMD 和希尔伯特谱分析得到瞬时频率。</li><li><strong>Wigner-Ville 分布 (Wigner-Ville Distribution)</strong>: 提供高时间和频率分辨率，适用于线性和非线性信号，但可能会受到交叉项干扰。</li></ul><p>这些方法各有优缺点，选择哪种方法取决于信号的特性和具体的分析需求。</p><h2 id="Q3"><a href="#Q3" class="headerlink" title="Q3"></a>Q3</h2><p>要提取x个通道y个采样点的EEG信号的谱熵，可以按照以下步骤进行：</p><ol><li><p><strong>计算离散傅里叶变换 (DFT)</strong><br>对于每个通道的EEG信号数据，计算离散傅里叶变换 (DFT) 以获得频谱信息。</p><script type="math/tex; mode=display">X(m) = \text{DFT}(x(n))</script></li><li><p><strong>计算功率谱</strong><br>利用DFT的结果计算每个频率点的功率谱。</p><script type="math/tex; mode=display">s(m) = |X(m)|^2</script></li><li><p><strong>计算概率分布</strong><br>将功率谱转换为概率分布。</p><script type="math/tex; mode=display">p(m) = \frac{s(m)}{\sum_{i=1}^{N}s(i)}</script></li><li><p><strong>计算谱熵</strong><br>利用概率分布计算谱熵。</p><script type="math/tex; mode=display">H = -\sum_{m=1}^{N} p(m) \log_2 p(m)</script></li><li><p><strong>计算归一化谱熵</strong><br>将谱熵归一化。</p><script type="math/tex; mode=display">H_n = \frac{-\sum_{m=1}^{N} p(m) \log_2 p(m)}{\log_2 N}</script></li><li><p><strong>时间-频率功率谱图</strong><br>若要计算瞬时谱熵，则需先计算时间-频率功率谱图。</p><script type="math/tex; mode=display">S(t, f)</script></li><li><p><strong>时间-频率域概率分布</strong><br>计算时间-频率域概率分布。</p><script type="math/tex; mode=display">p(t, m) = \frac{S(t, m)}{\sum_{f} S(t, f)}</script></li><li><p><strong>计算瞬时谱熵</strong><br>利用时间-频率域的概率分布计算瞬时谱熵。</p><script type="math/tex; mode=display">H(t) = -\sum_{m=1}^{N} p(t, m) \log_2 p(t, m)</script></li></ol><p>以下是一个简单的Python示例代码，用于计算单通道EEG信号的谱熵。可以根据需要修改代码以处理多通道和多时间点的信号。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.fft <span class="keyword">import</span> fft</span><br><span class="line"><span class="keyword">from</span> scipy.signal <span class="keyword">import</span> spectrogram</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compute_spectral_entropy</span>(<span class="params">signal, sampling_rate</span>):</span><br><span class="line">    <span class="comment"># Step 1: Compute the power spectrum</span></span><br><span class="line">    N = <span class="built_in">len</span>(signal)</span><br><span class="line">    fft_values = fft(signal)</span><br><span class="line">    power_spectrum = np.<span class="built_in">abs</span>(fft_values) ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Step 2: Compute the probability distribution</span></span><br><span class="line">    power_spectrum_sum = np.<span class="built_in">sum</span>(power_spectrum)</span><br><span class="line">    prob_distribution = power_spectrum / power_spectrum_sum</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Step 3: Compute the spectral entropy</span></span><br><span class="line">    spectral_entropy = -np.<span class="built_in">sum</span>(prob_distribution * np.log2(prob_distribution))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Step 4: Compute the normalized spectral entropy</span></span><br><span class="line">    max_entropy = np.log2(N)</span><br><span class="line">    normalized_spectral_entropy = spectral_entropy / max_entropy</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> normalized_spectral_entropy</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example usage</span></span><br><span class="line">eeg_signal = np.random.randn(<span class="number">256</span>)  <span class="comment"># Example EEG signal with 256 samples</span></span><br><span class="line">sampling_rate = <span class="number">256</span>  <span class="comment"># Example sampling rate in Hz</span></span><br><span class="line">entropy = compute_spectral_entropy(eeg_signal, sampling_rate)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Normalized Spectral Entropy: <span class="subst">&#123;entropy&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>对于多通道EEG信号，可以将上述代码包装在一个循环中，以计算每个通道的谱熵，然后根据需要进行进一步处理。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Q1&quot;&gt;&lt;a href=&quot;#Q1&quot; class=&quot;headerlink&quot; title=&quot;Q1&quot;&gt;&lt;/a&gt;Q1&lt;/h2&gt;&lt;p&gt;计算功率谱密度（Power Spectral Density, PSD）的常见算法有以下几种，每种算法的计算结果略有不同，适用于不同的场景。</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Use Google like a pro</title>
    <link href="https://kryptonzy.github.io/blog/2024/06/05/google%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>https://kryptonzy.github.io/blog/2024/06/05/google%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</id>
    <published>2024-06-05T02:56:58.592Z</published>
    <updated>2024-06-11T16:48:29.009Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Use-Google-like-a-pro"><a href="#Use-Google-like-a-pro" class="headerlink" title="Use Google like a pro"></a>Use Google like a pro</h1><p>原文地址：Use Google like a pro</p><p>原文作者：Marko Denic</p><p>译者：Gopal</p><h3 id="1-使用引号强制进行精确匹配搜索"><a href="#1-使用引号强制进行精确匹配搜索" class="headerlink" title="1. 使用引号强制进行精确匹配搜索"></a><strong>1. 使用引号强制进行精确匹配搜索</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“what is javascript&quot;</span><br></pre></td></tr></table></figure><h3 id="2-And-运算符"><a href="#2-And-运算符" class="headerlink" title="2. And 运算符"></a><strong>2. And 运算符</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">html AND css</span><br></pre></td></tr></table></figure><h3 id="3-使用-OR-操作符获取搜索词中某一个的结果"><a href="#3-使用-OR-操作符获取搜索词中某一个的结果" class="headerlink" title="3.  使用 OR 操作符获取搜索词中某一个的结果"></a><strong>3.  使用 OR 操作符获取搜索词中某一个的结果</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(javascript OR python) free course</span><br></pre></td></tr></table></figure><h3 id="4-操作符将排除包含搜索词的结果"><a href="#4-操作符将排除包含搜索词的结果" class="headerlink" title="4. - 操作符将排除包含搜索词的结果"></a><strong>4. - 操作符将排除包含搜索词的结果</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javascript -css</span><br></pre></td></tr></table></figure><h3 id="5-可以使用-通配符作为占位符，它将被任何单词或短语替换"><a href="#5-可以使用-通配符作为占位符，它将被任何单词或短语替换" class="headerlink" title="5. 可以使用 (*) 通配符作为占位符，它将被任何单词或短语替换"></a><strong>5. 可以使用 (*) 通配符作为占位符，它将被任何单词或短语替换</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;how to start * in 6 months&quot;</span><br></pre></td></tr></table></figure><h3 id="6-在一个单一的网站搜索"><a href="#6-在一个单一的网站搜索" class="headerlink" title="6. 在一个单一的网站搜索"></a><strong>6. 在一个单一的网站搜索</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:freecodecamp.org</span><br></pre></td></tr></table></figure><h3 id="7-查找特定的文件类型"><a href="#7-查找特定的文件类型" class="headerlink" title="7.  查找特定的文件类型"></a><strong>7.  查找特定的文件类型</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filetype:pdf learn css</span><br></pre></td></tr></table></figure><h3 id="8-搜索一个数字范围"><a href="#8-搜索一个数字范围" class="headerlink" title="8. 搜索一个数字范围"></a><strong>8. 搜索一个数字范围</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ecmascript 2016..2018</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Use-Google-like-a-pro&quot;&gt;&lt;a href=&quot;#Use-Google-like-a-pro&quot; class=&quot;headerlink&quot; title=&quot;Use Google like a pro&quot;&gt;&lt;/a&gt;Use Google like a pro&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>欧拉公式与初等群论</title>
    <link href="https://kryptonzy.github.io/blog/2024/06/04/%E6%AC%A7%E6%8B%89%E5%85%AC%E5%BC%8F%E4%B8%8E%E5%88%9D%E7%AD%89%E7%BE%A4%E8%AE%BA/"/>
    <id>https://kryptonzy.github.io/blog/2024/06/04/%E6%AC%A7%E6%8B%89%E5%85%AC%E5%BC%8F%E4%B8%8E%E5%88%9D%E7%AD%89%E7%BE%A4%E8%AE%BA/</id>
    <published>2024-06-04T05:39:34.307Z</published>
    <updated>2024-06-12T06:00:18.540Z</updated>
    
    <content type="html"><![CDATA[<h1 id="欧拉公式与初等群论"><a href="#欧拉公式与初等群论" class="headerlink" title="欧拉公式与初等群论"></a>欧拉公式与初等群论</h1><p>来源：<a href="https://www.bilibili.com/video/BV1fx41187tZ/">https://www.bilibili.com/video/BV1fx41187tZ/</a></p><h2 id="群论就是研究对称性本质的一个领域"><a href="#群论就是研究对称性本质的一个领域" class="headerlink" title="群论就是研究对称性本质的一个领域"></a>群论就是研究对称性本质的一个领域</h2><p>“群”是“对称群”的简称</p><p>加法群（一维）：平移</p><p>乘法群（一维）：缩放</p><p>复数加法群（二维）：平移+垂直方向平移</p><p>复数乘法群（二维）：缩放+旋转</p><h2 id="群就是某个数学对象上对称作用的集合"><a href="#群就是某个数学对象上对称作用的集合" class="headerlink" title="群就是某个数学对象上对称作用的集合"></a>群就是某个数学对象上对称作用的集合</h2><p>对于指数函数的性质</p><p>2^(x+y)=2^x*2^y</p><p>把指数函数的输入看作加法群的滑动作用，输出看作乘法群的缩放+旋转</p><h2 id="欧拉公式"><a href="#欧拉公式" class="headerlink" title="欧拉公式"></a>欧拉公式</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;欧拉公式与初等群论&quot;&gt;&lt;a href=&quot;#欧拉公式与初等群论&quot; class=&quot;headerlink&quot; title=&quot;欧拉公式与初等群论&quot;&gt;&lt;/a&gt;欧拉公式与初等群论&lt;/h1&gt;&lt;p&gt;来源：&lt;a href=&quot;https://www.bilibili.com/video</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://kryptonzy.github.io/blog/2024/04/22/hello-world/"/>
    <id>https://kryptonzy.github.io/blog/2024/04/22/hello-world/</id>
    <published>2024-04-22T06:54:21.035Z</published>
    <updated>2024-04-22T06:54:21.036Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
